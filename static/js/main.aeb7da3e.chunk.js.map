{"version":3,"sources":["components/colors.js","components/controllers/SolveButton.tsx","model/grid/NodeEngine.ts","model/animations/AnimationsEngine.ts","model/algorithms/Dijkstra.ts","model/grid/GridEngine.tsx","model/algorithms/DFS.ts","model/algorithms/BiderectionalBfs.ts","model/algorithms/outils/AlgorithmsEngine.ts","model/algorithms/A*.ts","model/algorithms/BFS.ts","components/imgs/dog.svg","components/controllers/AlgorithmMenu.tsx","components/imgs/steak-svgrepo-com.svg","components/viewer/Node.tsx","components/viewer/Canvas.tsx","model/mazes/RecursiveDivision.ts","model/mazes/outils.ts","model/mazes/Prim2.ts","model/mazes/random.tsx","model/mazes/MazesEngine.ts","components/controllers/MazesMenu.tsx","components/controllers/SpeedSlider.tsx","model/animations/toggleWallAnimation.ts","components/controllers/ClearButton.tsx","components/viewer/InformationBox.tsx","components/viewer/InformationBoxMaze.tsx","App.tsx","components/presentation/WelcomeGuide.tsx","components/presentation/tutorial/FunctionButtonsExplanation.tsx","components/presentation/tutorial/AlgorithmMazeExplanation.tsx","components/presentation/tutorial/InformationBoxExplanation.tsx","components/presentation/tutorial/CanvasInformation.tsx","components/presentation/tutorial/Tutorial.tsx","MainApp.tsx","index.js"],"names":["solveButtonColor","welcomeText","algorithmsDropDownColor","mazesDropDownColor","speedSliderColor","fontColor","emptyNodeColor","wallColor","shortestPathColor","unreachableColor","SolveButton","width","clicked","isBusy","ButtonGroup","orientation","variant","sx","marginBottom","marginLeft","Button","backgroundColor","color","fontWeight","onClick","disabled","NodeType","this","Empty","Start","End","Wall","None","Point","row","col","NodeBackEnd","nodeType","isVisited","distance","previous","coords","isWall","parent","Infinity","MazeNodeBackEnd","previousAdjacent","edge","vertex","AnimationType","duration","node","animate","scale","ReachedNode","SelectedNode","WallNode","ShortesPathNode","Unreachable","EmptyNode","Color","style","background","ShortestPath","Animation","type","apply","document","getElementById","toggleWallAnimation","noSolutionAnimations","animations","noSolutionsAnimations","i","length","push","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","updateUnvisitedNeighbors","grid","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","getShortestPathAnimation","finishNode","currentNode","updateGrid","oldGrid","columns","rows","start","end","currentRow","removeStartEndCoordinate","newGrid","slice","getAdjacent","current","nodes","validCoordinate","recursiveDfs","neighbour","bfs","identifier","otherIdentifier","queue","shift","undefined","require","Algorithm","getAnimation","name","text","getAnimations","Dijkstra","getAllNodes","closestNode","concat","Astar","Bfs","Dfs","console","log","Stack","BidirectionalBFS","startQueue","destQueue","_g","_g2","_g3","_g4","_g5","_g6","_g7","_g8","_g9","_g10","_g11","_g12","_g13","_g14","_g15","AlgorithmMenu","defaultAlgorithm","buttonSx","useState","expandRef","useRef","toggleAndClicked","algorithm","click","direction","Accordion","AccordionSummary","expandIcon","id","ref","Typography","fontSize","paddingLeft","AccordionDetails","marginTop","_excluded","_extends","Object","assign","target","arguments","source","key","prototype","hasOwnProperty","call","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","SvgDog","_ref","svgRef","title","titleId","props","xmlns","xmlnsXlink","x","y","viewBox","enableBackground","xmlSpace","fill","d","ForwardRef","SvgSteakSvgrepoCom","Node","size","mouseDown","mouseEnter","mouseUp","height","display","className","onMouseDown","onMouseEnter","onMouseUp","Canvas","squareSize","mousePressed","Box","margin","outline","map","rowIdx","colIdx","prop","mouseIsPressed","recursiveDivision","h","minX","maxX","minY","maxY","Math","floor","randomNumber","hole","addHWall","addVWall","min","max","random","randomIntFromInterval","getAdjacentMSPPairs","getAdjacentPairs","adjacent","visitedIs","updatePath","possiblePath","randomIdx","spanned","visited","validWall","adjacents","getAllAdjacent","Maze","Prim","j","unVisited","animation","buildGraphRepresentation","pop","adjacentPairs","JSON","parse","stringify","Custom","Random","possibleWalls","setPossibleWalls","array","randomIndex","currentIndex","shuffle","RecursiveDivison","addContour","MazesMenu","mazeSelected","maze","SpeedSlider","minSpeed","maxSpeed","defaultSpeed","handleSpeedSlider","paddingTop","marginRight","alignItems","flexWrap","Slider","defaultValue","onChange","getWallToggleAnimation","toggle","ClearButton","InformationBoxAlgorithm","show","setShow","useEffect","Slide","in","mountOnEnter","unmountOnExit","padding","paddingRight","Link","href","InformationBoxMaze","App","stackWidth","MAX_ANIMATION_SPEED","animationSpeed","setAnimationSpeed","setMousePressed","setIsBusy","startCoordinate","setStartCoordinate","endCoordinate","setEndCoordinate","startNodeSelected","setStartNodeSelected","endNodeSelected","setEndNodeSelected","setAlgorithm","setMaze","setGrid","applyAnimations","speed","setTimeout","initializeGrid","clearGrid","bind","startNode","endNode","defaultAnimationSpeed","event","number","newMaze","prevState","buttonStyle","WelcomeGuide","close","startTutorial","widthBox","heightBox","Modal","open","onClose","FunctionButtonTutorial","explanationBoxStyle","textStyleTutorial","buttonStyleTutorial","AlgorithmMazeTutorial","CanvasInformation","Tutorial","setCurrent","tutorialSteps","next","prev","MainApp","closestOddNumber","num","round","useWindowSize","welcome","showWelcome","setStartTutorial","ReactDOM","render","StrictMode"],"mappings":"yNACaA,EAAmB,UAEnBC,EAAc,yBACdC,EAA0B,yBAG1BC,EAAqB,mBAKrBC,EAAkB,UAKlBC,EAAY,OAEZC,EAAiB,mBAEjBC,EAAY,sBAEZC,EAAoB,UAIpBC,EAAmB,U,OClBnBC,EAAc,SAAC,GAAgD,IAA/CC,EAA8C,EAA9CA,MAAOC,EAAuC,EAAvCA,QAASC,EAA8B,EAA9BA,OACzC,OACI,cAACC,EAAA,EAAD,CACIC,YAAY,WACZ,aAAW,kCACXC,QAAQ,YACZC,GAAI,CAACC,aAAc,EAAGC,WAAY,GAJlC,SAMA,cAACC,EAAA,EAAD,CAAQH,GAAI,CACRI,gBAAiBrB,EACjBsB,MAAOjB,EACPkB,WAAY,OACZZ,MAAe,IAARA,GAEXa,QAASZ,EAASa,SAAUZ,EAN5B,2B,oFCfKa,EAAb,aAWI,WAAYJ,GAAgB,yBAHrBA,WAGoB,EACvBK,KAAKL,MAAQA,KAZRI,EAEFE,MAAkB,IAAIF,EAASpB,GAF7BoB,EAGFG,MAAkB,IAAIH,EAASpB,GAH7BoB,EAIFI,IAAgB,IAAIJ,EAASpB,GAJ3BoB,EAKFK,KAAiB,IAAIL,EAAS,uBAL5BA,EAMFM,KAAiB,IAAIN,EAAS,IAWlC,IAAMO,EAAb,aAII,WAAYC,EAAaC,GAAc,yBAHhCD,SAG+B,OAF/BC,SAE+B,EAClCR,KAAKQ,IAAMA,EACXR,KAAKO,IAAMA,KAMNE,EAAb,WAaI,WAAYC,EAAoBH,EAAaC,GAAc,yBATpDE,cASmD,OARnDC,eAQmD,OAPnDC,cAOmD,OANnDC,cAMmD,OALnDC,YAKmD,OAJnDC,YAImD,OAHnDpB,WAGmD,OAFnDqB,YAEmD,EACtDhB,KAAKgB,OAAS,GACdhB,KAAKU,SAAWA,EAChBV,KAAKW,WAAY,EACjBX,KAAKY,SAAWK,IAChBjB,KAAKa,SAAYJ,EAAYJ,KAC7BL,KAAKc,OAAS,IAAIR,EAAMC,EAAKC,GAC7BR,KAAKe,OAASL,IAAaX,EAASK,KACpCJ,KAAKL,MAAQe,EAASf,MArB9B,0CAwBI,WAEI,OADAK,KAAKe,QAAS,EACPf,OA1Bf,uBA6BI,WACI,OAAOA,KAAKW,YA9BpB,qBAiCI,WACIX,KAAKW,WAAY,IAlCzB,uBAqCI,WACIX,KAAKW,WAAY,MAtCzB,KAAaF,EAEFJ,KAAO,IAAII,EAAYV,EAASM,MAAO,GAAI,GA+C/C,IAAMa,EAAb,kDAOI,WAAYR,EAAoBH,EAAaC,GAAc,IAAD,8BACtD,cAAME,EAAUH,EAAKC,IAJlBW,sBAGmD,EAEtD,EAAKA,iBAAmB,CAACC,KAAMF,EAAgBb,KAAMgB,OAAQH,EAAgBb,MAFvB,EAP9D,uBAAqCI,GAAxBS,EAEFb,KAAO,IAAIa,EAAgBnB,EAASM,MAAO,GAAI,G,OAanD,ICnFMiB,EAAb,WAWI,WAAYC,EAAkB5B,GAAgB,yBAH7B4B,cAG4B,OAF5B5B,WAE4B,EACzCK,KAAKuB,SAAWA,EAChBvB,KAAKL,MAAQA,EAbrB,yCAgBI,SAAM6B,GACFA,EAAKC,QACF,CAAC/B,gBAAiB,CAACM,KAAKL,MAAOhB,GAAiB+C,MAAO,CAAC,GAAK,IAC9D1B,KAAKuB,cAnBf,KAAaD,EACFK,YAA6B,IAAIL,EAAc,IAAMjD,GADnDiD,EAEFM,aAA8B,IAAIN,EAAc,IAAM7C,GAFpD6C,EAGFO,SAA0B,IAAIP,EAAc,IAAK1C,GAH/C0C,EAIFQ,gBAAiC,IAAIR,EAAc,IAAMzC,GAJvDyC,EAKFS,YAA6B,IAAIT,EAAc,IAAMxC,GALnDwC,EAMFU,UAA2B,IAAIV,EAAc,IAAK3C,GAiBtD,IAAMsD,EAAb,WAQI,WAAYtC,GAAgB,yBAFXA,WAEU,EACvBK,KAAKL,MAAQA,EATrB,yCAYI,SAAM6B,GACFA,EAAKU,MAAMC,WAAanC,KAAKL,UAbrC,KAAasC,EACF7B,KAAc,IAAI6B,EAAMrD,GADtBqD,EAEFG,aAAsB,IAAIH,EAAMpD,GAF9BoD,EAGFhC,MAAe,IAAIgC,EAAMtD,GAHvBsD,EAIFF,YAAqB,IAAIE,EAAMnD,GAanC,IAiBMuD,EAAb,WAKI,WAAYC,EAA6Bd,GAAoB,yBAHrDc,UAGoD,OAFrDd,UAEqD,EACxDxB,KAAKsC,KAAOA,EACZtC,KAAKwB,KAAOA,EAPpB,yCAUI,WAEIxB,KAAKsC,KAAKC,MAAMC,SAASC,eAAT,aAA8BzC,KAAKwB,KAAKV,OAAOP,IAA/C,cAAwDP,KAAKwB,KAAKV,OAAON,WAZjG,KAiBO,SAASkC,EAAoBlB,GAChC,MAAO,CAAC,IAAIa,EAAUf,EAAcO,SAAUL,GAAO,IAAIa,EAAUJ,EAAM7B,KAAMoB,IAO5E,SAASmB,EAAqBC,GAIjC,IAFA,IAAMC,EAAqC,GAElCC,EAAI,EAAGA,EAAIF,EAAWG,OAAQD,IACpCD,EAAsBG,KAAK,IAAIX,EAAUf,EAAcS,YAAaa,EAAWE,GAAGtB,OAClFqB,EAAsBG,KAAK,IAAIX,EAAUJ,EAAMF,YAAaa,EAAWE,GAAGtB,OAG7E,OAAOqB,ECnEX,SAASI,EAAoBC,GACzBA,EAAeC,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMxC,SAAWyC,EAAMzC,YAGjE,SAAS0C,EAAyB9B,EAAmB+B,GACjD,IADwE,EAClEC,EAOV,SAA+BhC,EAAmB+B,GAC9C,IAAME,EAAY,GAClB,EAAmB,CAACjC,EAAKV,OAAOP,IAAKiB,EAAKV,OAAON,KAA1CD,EAAP,KAAYC,EAAZ,KACID,EAAM,GAAGkD,EAAUT,KAAKO,EAAKhD,EAAM,GAAGC,IACtCD,EAAMgD,EAAKR,OAAS,GAAGU,EAAUT,KAAKO,EAAKhD,EAAM,GAAGC,IACpDA,EAAM,GAAGiD,EAAUT,KAAKO,EAAKhD,GAAKC,EAAM,IACxCA,EAAM+C,EAAK,GAAGR,OAAS,GAAGU,EAAUT,KAAKO,EAAKhD,GAAKC,EAAM,IAC7D,OAAOiD,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAAShD,aAdnBiD,CAAsBpC,EAAM+B,GADiB,cAEjDC,GAFiD,IAExE,2BAA2C,CAAC,IAAjCG,EAAgC,QACvCA,EAAS/C,SAAWY,EAAKZ,SAAW,EACpC+C,EAAS9C,SAAWW,GAJgD,+BAqCrE,SAASqC,EAAyBC,GAIrC,IAHA,IAAMlB,EAA0B,GAC5BmB,EAAcD,EAEXC,EAAYrD,WAAaX,EAASM,MACrCuC,EAAWI,KAAK,IAAIX,EAAUf,EAAcQ,gBAAiBiC,IAC7DA,EAAcA,EAAYlD,SAG9B,OAAO+B,EC/DJ,SAASoB,EAAWC,EAAmCC,EAAiBC,EAAcC,EAAcC,GAGvG,IAFA,IAAMd,EAAO,GAEJhD,EAAM,EAAGA,EAAM4D,EAAM5D,IAAO,CAEjC,IADA,IAAM+D,EAAa,GACV9D,EAAM,EAAGA,EAAM0D,EAAS1D,IAC3ByD,EAAQ1D,GAAKC,GAAKO,OACjBuD,EAAWtB,KAAK,IAAIvC,EAAYV,EAASK,KAAMG,EAAKC,IAEpD8D,EAAWtB,KAAK,IAAIvC,EAAYV,EAASE,MAAOM,EAAKC,IAE5D+C,EAAKP,KAAKsB,GAMd,OAHAf,EAAKa,EAAM7D,KAAK6D,EAAM5D,KAAO,IAAIC,EAAYV,EAASG,MAAOkE,EAAM7D,IAAK6D,EAAM5D,KAC9E+C,EAAKc,EAAI9D,KAAK8D,EAAI7D,KAAO,IAAIC,EAAYV,EAASI,IAAKkE,EAAI9D,IAAK8D,EAAI7D,KAE7D+C,EA2BJ,SAASgB,EAAyBhB,EAAuBa,GAC5D,IAAMI,EAAUjB,EAAKkB,QAErB,OADAD,EAAQJ,EAAM7D,KAAK6D,EAAM5D,KAAO,IAAIC,EAAYV,EAASE,MAAOmE,EAAM7D,IAAK6D,EAAM5D,KAC1EgE,EAKJ,SAASE,EAAYC,EAAsBpB,GAE9C,IAAMqB,EAAuB,GAGzBrE,EAAMoE,EAAQ7D,OAAOP,IAAM,EAC3BC,EAAMmE,EAAQ7D,OAAON,IAsBzB,OArBGqE,EAAgBtE,EAAKC,EAAK+C,IACzBqB,EAAM5B,KAAKO,EAAKhD,GAAKC,IAKtBqE,EAFHtE,EAAMoE,EAAQ7D,OAAOP,IACrBC,EAAMmE,EAAQ7D,OAAON,IAAM,EACE+C,IACzBqB,EAAM5B,KAAKO,EAAKhD,GAAKC,IAKtBqE,EAFHtE,EAAMoE,EAAQ7D,OAAOP,IAAM,EAC3BC,EAAMmE,EAAQ7D,OAAON,IACQ+C,IACzBqB,EAAM5B,KAAKO,EAAKhD,GAAKC,IAKtBqE,EAFHtE,EAAMoE,EAAQ7D,OAAOP,IACrBC,EAAMmE,EAAQ7D,OAAON,IAAM,EACE+C,IACzBqB,EAAM5B,KAAKO,EAAKhD,GAAKC,IAElBoE,EAkCJ,SAASC,EAAgBtE,EAAaC,EAAa+C,GACtD,QAAShD,GAAOgD,EAAKR,QAAUxC,EAAM,GAAKC,GAAO+C,EAAK,GAAGR,QAAUvC,EAAM,G,aCrH7E,SAASsE,EAAavB,EAAuBoB,EAAsBN,EAAkBzB,GACjFW,EAAKoB,EAAQ7D,OAAOP,KAAKoE,EAAQ7D,OAAON,KAAKG,WAAY,EACzDiC,EAAWI,KAAK,IAAIX,EAAUf,EAAcK,YAAagD,IAFuD,oBAK3ED,EAAYC,EAASpB,IALsD,IAKhH,2BAAiE,CAAC,IAAvDwB,EAAsD,QAE7D,GAAGA,EAAUjE,OAAON,MAAQ6D,EAAIvD,OAAON,KAAOuE,EAAUjE,OAAOP,MAAQ8D,EAAIvD,OAAOP,IAG9E,OAFA8D,EAAI1D,WAAY,OAChB0D,EAAIxD,SAAW8D,GAIdI,EAAUpE,WAAcoE,EAAUhE,QAAWsD,EAAI1D,YAClDmE,EAAavB,EAAMwB,EAAWV,EAAKzB,GACnCmC,EAAUlE,SAAW8D,IAfmF,+BCoBpH,SAASK,EAAIC,EAAoBC,EAAyBC,EAAsB5B,EAAuBX,GAEnG,IAAI+B,EAAmCQ,EAAMC,QAC7C,QAAgBC,IAAZV,EAAuB,OAAO,EAElC/B,EAAWI,KAAK,IAAIX,EAAUf,EAAcK,YAAagD,IAL4E,oBAOhHD,EAAYC,EAASpB,IAP2F,IAOrI,2BAAiD,CAAC,IAAvClC,EAAsC,QAE7C,GAAIA,EAAOL,SAAWkE,EAIlB,OAHAtC,EAAWI,KAAK,IAAIX,EAAUf,EAAcK,YAAaN,IACzDuB,EAAWI,KAAX,MAAAJ,EAAU,YAASiB,EAAyBxC,KAC5CuB,EAAWI,KAAX,MAAAJ,EAAU,YAASiB,EAAyBc,MACrC,EAGNtD,EAAOV,WAAcU,EAAON,SAC7BoE,EAAMnC,KAAK3B,GACXA,EAAOV,WAAY,EACnBU,EAAOR,SAAW8D,EAClBtD,EAAOL,OAASiE,IApB6G,8BAwBrI,OAAO,ED5DXK,EAAQ,KEKR,IAiCaC,EAAb,aAYI,WAAYC,EAAmBC,EAAcC,GAAe,yBAJ5CC,mBAI2C,OAH3CF,UAG2C,OAF3CC,UAE2C,EACvD1F,KAAK2F,cAAgBH,EACrBxF,KAAKyF,KAAOA,EACZzF,KAAK0F,KAAOA,KAfPH,EAEFK,SAAW,IAAIL,GJ1CnB,SAA+BhC,EAAuBa,EAAoBC,GAE7E,IAAIzB,EAA0B,GAC9BwB,EAAMxD,SAAW,EAKjB,IAJA,IAAMsC,EAmDV,SAAqBK,GACjB,IADuD,EACjDqB,EAAQ,GADyC,cAErCrB,GAFqC,IAEvD,2BAAwB,CAAC,IAAD,EAAbhD,EAAa,sBACDA,GADC,IACpB,2BAAwB,CAAC,IAAdiB,EAAa,QACpBoD,EAAM5B,KAAKxB,IAFK,gCAF+B,8BAOvD,OAAOoD,EA1DgBiB,CAAYtC,GAI1BL,EAAeH,QAAQ,CAC5BE,EAAoBC,GAEpB,IAAM4C,EAAuC5C,EAAekC,QAC5D,QAAmBC,IAAhBS,EAA2B,MAAO,GAGrC,IAAIA,EAAY/E,OAAhB,CAGA,GAAI+E,EAAYlF,WAAaK,IAAU,OAAO2B,EAAWmD,OAAX,MAAAnD,EAAU,YAAWD,EAAqBC,KAQxF,GANAkD,EAAYnF,WAAY,EACxBiC,EAAWI,KAAK,IAAIX,EAAUf,EAAcK,YAAamE,IAEzDxC,EAAyBwC,EAAavC,GAGlCuC,EAAYhF,OAAOP,MAAQ8D,EAAIvD,OAAOP,KAAOuF,EAAYhF,OAAON,MAAQ6D,EAAIvD,OAAON,IACnF,OAAOoC,EAAWmD,OAAX,MAAAnD,EAAU,YAAWiB,EAAyBQ,MAG7D,MAAO,KIYgD,WAnCzC,2bAiCLkB,EAGFS,MAAQ,IAAIT,GCzChB,SAA4BhC,EAAuBa,EAAoBC,GAI1E,MAAO,KDqC0C,KA3BtC,IAwBFkB,EAIFU,IAAM,IAAIV,GE1Cd,SAA0BhC,EAAuBa,EAAoBC,GAExE,IAAMzB,EAA0B,GAC1BuC,EAAuB,GAK7B,IAHAA,EAAMnC,KAAKoB,GACXA,EAAMzD,WAAY,EAEK,IAAjBwE,EAAMpC,QAAc,CAEtB,IAAI4B,EAAmCQ,EAAMC,QAC7C,QAAeC,IAAZV,EAAuB,MAAO,GAEjC/B,EAAWI,KAAK,IAAIX,EAAUf,EAAcK,YAAagD,IALnC,oBAQFD,EAAYC,EAASpB,IARnB,IAQtB,IAAI,EAAJ,qBAAgD,CAAC,IAAD,EAAtClC,EAAsC,QAO7C,GANIA,EAAOV,WAAcU,EAAON,SAC5BoE,EAAMnC,KAAK3B,GACXA,EAAOV,WAAY,EACnBU,EAAOR,SAAW8D,GAGnBtD,IAAWgD,EACV,OAAO,EAAAzB,EAAWmD,OAAO,IAAI1D,EAAUf,EAAcK,YAAaN,KAAS0E,OAApE,oBAA8ElC,EAAyBQ,MAhB/F,+BAsB1B,OAAOzB,EAAWmD,OAAX,MAAAnD,EAAU,YAAWD,EAAqBC,OFYJ,MA1BpC,kYAsBA2C,EAKFW,IAAM,IAAIX,GFzCd,SAA0BhC,EAAuBa,EAAoBC,GAExE8B,QAAQC,IAAI,cAEZ,IAAMxD,EAA0B,CAAC,IAAIP,EAAUf,EAAcK,YAAayC,IAO1E,OANmB,IAAIiC,SAEjBrD,KAAKoB,GAEXU,EAAavB,EAAMa,EAAOC,EAAKzB,GAEvBA,EAAWmD,OAAX,MAAAnD,EAAU,YAAWiB,EAAyBQ,EAAIxD,cE8Bb,MAnBpC,2VAcA0E,EAMFe,iBAAmB,IAAIf,GD1C3B,SAAuChC,EAAuBa,EAAoBC,GAErF,IAAMzB,EAA0B,GAI1B2D,EAA4B,GAClCA,EAAWvD,KAAKoB,GAChBA,EAAMzD,WAAY,EAGlB,IAAM6F,EAA2B,GAMjC,IALAA,EAAUxD,KAAKqB,GACfA,EAAI1D,WAAY,EAIa,IAAtB4F,EAAWxD,QAAqC,IAArByD,EAAUzD,QAKxC,GAAIiC,EAAI,QAAS,MAAOuB,EAAYhD,EAAMX,IAAeoC,EAAI,MAAO,QAASwB,EAAWjD,EAAMX,GAC1F,OAAOA,EAAWmD,OAAX,MAAAnD,EAAU,YAAWiB,EAAyBO,KAM7D,OAAOxB,EAAWmD,OAAX,MAAAnD,EAAU,YAAWD,EAAqBC,OCasB,OAbjD,mR,IGpCtB6D,GAAIC,GAAKC,GAAKC,GAAKC,GAAKC,GAAKC,GAAKC,GAAKC,GAAKC,GAAMC,GAAMC,GAAMC,GAAMC,GAAMC,G,oBCuBjEC,GAAgB,SAAC,GAAoE,IAAnExI,EAAkE,EAAlEA,MAAOC,EAA2D,EAA3DA,QAASC,EAAkD,EAAlDA,OAAQuI,EAA0C,EAA1CA,iBAE7CC,EAAW,CAAChI,gBZpBkB,yBYoByBV,MAAe,IAARA,GACpE,EAAgC2I,oBAAS,GAAzC,mBACMC,GADN,UACkBC,iBAAO,OAEnBC,EAAmB,SAACC,GAElBH,EAAUjD,QAAQqD,QAClB/I,EAAQ8I,IAGhB,OACI,cAAC1B,EAAA,EAAD,CAAO4B,UAAU,SAASjJ,MAAOA,EAAjC,SACI,eAACkJ,EAAA,EAAD,CAAW5I,GAAI,CACXI,gBAAiBnB,EACjBoB,MAAOjB,EACPa,aAAc,GACfO,SAAUZ,EAJb,UAKI,eAACiJ,EAAA,EAAD,CACIC,WAAY,cAAC,KAAD,CAAgB9I,GAAI,CAACK,MAAOjB,KACxC,gBAAc,kBACd2J,GAAG,iBACH/I,GAAI,CAACC,aAAc,GAAI+I,IAAKV,EAJhC,UAKI,cAACW,EAAA,EAAD,CAAY3I,WAAW,OAAO4I,SAAU,GAAxC,yBACD,eAACD,EAAA,EAAD,CAAYE,YAAa,EAAGD,SAAU,GAAtC,eAA6Cf,EAAiBhC,WAEjE,cAACiD,EAAA,EAAD,CAAkBpJ,GAAI,CAACC,aAAc,GAArC,SACI,eAACJ,EAAA,EAAD,CACIC,YAAY,WACZ,aAAW,kCACXC,QAAQ,YACRC,GAAI,CAACqJ,UAAW,GAJpB,UAKI,cAAClJ,EAAA,EAAD,CAAQH,GAAIoI,EAAU7H,QAAS,kBAAMiI,EAAiBvC,EAAUe,mBAAhE,oBACA,cAAC7G,EAAA,EAAD,CAAQH,GAAIoI,EAAU7H,QAAS,kBAAMiI,EAAiBvC,EAAUK,WAAhE,wBACA,cAACnG,EAAA,EAAD,CAAQH,GAAIoI,EAAU7H,QAAS,kBAAMiI,EAAiBvC,EAAUU,MAAhE,mBACA,cAACxG,EAAA,EAAD,CAAQH,GAAIoI,EAAU7H,QAAS,kBAAMiI,EAAiBvC,EAAUW,MAAhE,8B,mBDzDpB0C,GAAY,CAAC,QAAS,WAE1B,SAASC,KAA2Q,OAA9PA,GAAWC,OAAOC,QAAU,SAAUC,GAAU,IAAK,IAAIlG,EAAI,EAAGA,EAAImG,UAAUlG,OAAQD,IAAK,CAAE,IAAIoG,EAASD,UAAUnG,GAAI,IAAK,IAAIqG,KAAOD,EAAcJ,OAAOM,UAAUC,eAAeC,KAAKJ,EAAQC,KAAQH,EAAOG,GAAOD,EAAOC,IAAY,OAAOH,GAAkBH,GAAStG,MAAMvC,KAAMiJ,WAEhT,SAASM,GAAyBL,EAAQM,GAAY,GAAc,MAAVN,EAAgB,MAAO,GAAI,IAAkEC,EAAKrG,EAAnEkG,EAEzF,SAAuCE,EAAQM,GAAY,GAAc,MAAVN,EAAgB,MAAO,GAAI,IAA2DC,EAAKrG,EAA5DkG,EAAS,GAAQS,EAAaX,OAAOY,KAAKR,GAAqB,IAAKpG,EAAI,EAAGA,EAAI2G,EAAW1G,OAAQD,IAAOqG,EAAMM,EAAW3G,GAAQ0G,EAASG,QAAQR,IAAQ,IAAaH,EAAOG,GAAOD,EAAOC,IAAQ,OAAOH,EAFxMY,CAA8BV,EAAQM,GAAuB,GAAIV,OAAOe,sBAAuB,CAAE,IAAIC,EAAmBhB,OAAOe,sBAAsBX,GAAS,IAAKpG,EAAI,EAAGA,EAAIgH,EAAiB/G,OAAQD,IAAOqG,EAAMW,EAAiBhH,GAAQ0G,EAASG,QAAQR,IAAQ,GAAkBL,OAAOM,UAAUW,qBAAqBT,KAAKJ,EAAQC,KAAgBH,EAAOG,GAAOD,EAAOC,IAAU,OAAOH,EAMne,SAASgB,GAAOC,EAAMC,GACpB,IAAIC,EAAQF,EAAKE,MACbC,EAAUH,EAAKG,QACfC,EAAQd,GAAyBU,EAAMrB,IAE3C,OAAoB,gBAAoB,MAAOC,GAAS,CACtDR,GAAI,UACJiC,MAAO,6BACPC,WAAY,+BACZC,EAAG,MACHC,EAAG,MACHC,QAAS,sBACTxI,MAAO,CACLyI,iBAAkB,2BAEpBC,SAAU,WACVtC,IAAK4B,EACL,kBAAmBE,GAClBC,GAAQF,EAAqB,gBAAoB,QAAS,CAC3D9B,GAAI+B,GACHD,GAAS,KAAmB,gBAAoB,OAAQ,CACzDjI,MAAO,CACL2I,KAAM,WAERC,EAAG,+IACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,oIACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,kJACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,iIACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,8jBACY,gBAAoB,IAAK,KAAmB,gBAAoB,OAAQ,CACvF5I,MAAO,CACL2I,KAAM,WAERC,EAAG,gLACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,oLACa,gBAAoB,IAAK,KAAmB,gBAAoB,OAAQ,CACxF5I,MAAO,CACL2I,KAAM,WAERC,EAAG,8HACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,sUACa,gBAAoB,OAAQ,CAC5C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,snDACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,6hCACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,+QACDrE,KAAOA,GAAkB,gBAAoB,IAAK,OAAQC,KAAQA,GAAmB,gBAAoB,IAAK,OAAQC,KAAQA,GAAmB,gBAAoB,IAAK,OAAQC,KAAQA,GAAmB,gBAAoB,IAAK,OAAQC,KAAQA,GAAmB,gBAAoB,IAAK,OAAQC,KAAQA,GAAmB,gBAAoB,IAAK,OAAQC,KAAQA,GAAmB,gBAAoB,IAAK,OAAQC,KAAQA,GAAmB,gBAAoB,IAAK,OAAQC,KAAQA,GAAmB,gBAAoB,IAAK,OAAQC,KAASA,GAAoB,gBAAoB,IAAK,OAAQC,KAASA,GAAoB,gBAAoB,IAAK,OAAQC,KAASA,GAAoB,gBAAoB,IAAK,OAAQC,KAASA,GAAoB,gBAAoB,IAAK,OAAQC,KAASA,GAAoB,gBAAoB,IAAK,OAAQC,KAASA,GAAoB,gBAAoB,IAAK,QAG54B,IE/FI,GAAI,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAM,GAAM,GAAM,GAAM,GAAM,GF+F1EwD,GAA0B,aAAiBf,IE7F3C,IF8FW,IE9FC,CAAC,QAAS,YAE1B,SAAS,KAA2Q,OAA9P,GAAWlB,OAAOC,QAAU,SAAUC,GAAU,IAAK,IAAIlG,EAAI,EAAGA,EAAImG,UAAUlG,OAAQD,IAAK,CAAE,IAAIoG,EAASD,UAAUnG,GAAI,IAAK,IAAIqG,KAAOD,EAAcJ,OAAOM,UAAUC,eAAeC,KAAKJ,EAAQC,KAAQH,EAAOG,GAAOD,EAAOC,IAAY,OAAOH,GAAkB,GAASzG,MAAMvC,KAAMiJ,WAEhT,SAAS,GAAyBC,EAAQM,GAAY,GAAc,MAAVN,EAAgB,MAAO,GAAI,IAAkEC,EAAKrG,EAAnEkG,EAEzF,SAAuCE,EAAQM,GAAY,GAAc,MAAVN,EAAgB,MAAO,GAAI,IAA2DC,EAAKrG,EAA5DkG,EAAS,GAAQS,EAAaX,OAAOY,KAAKR,GAAqB,IAAKpG,EAAI,EAAGA,EAAI2G,EAAW1G,OAAQD,IAAOqG,EAAMM,EAAW3G,GAAQ0G,EAASG,QAAQR,IAAQ,IAAaH,EAAOG,GAAOD,EAAOC,IAAQ,OAAOH,EAFxM,CAA8BE,EAAQM,GAAuB,GAAIV,OAAOe,sBAAuB,CAAE,IAAIC,EAAmBhB,OAAOe,sBAAsBX,GAAS,IAAKpG,EAAI,EAAGA,EAAIgH,EAAiB/G,OAAQD,IAAOqG,EAAMW,EAAiBhH,GAAQ0G,EAASG,QAAQR,IAAQ,GAAkBL,OAAOM,UAAUW,qBAAqBT,KAAKJ,EAAQC,KAAgBH,EAAOG,GAAOD,EAAOC,IAAU,OAAOH,EAMne,SAASgC,GAAmBf,EAAMC,GAChC,IAAIC,EAAQF,EAAKE,MACbC,EAAUH,EAAKG,QACfC,EAAQ,GAAyBJ,EAAM,IAE3C,OAAoB,gBAAoB,MAAO,GAAS,CACtD5B,GAAI,UACJiC,MAAO,6BACPC,WAAY,+BACZC,EAAG,MACHC,EAAG,MACHC,QAAS,cACTxI,MAAO,CACLyI,iBAAkB,mBAEpBC,SAAU,WACVtC,IAAK4B,EACL,kBAAmBE,GAClBC,GAAQF,EAAqB,gBAAoB,QAAS,CAC3D9B,GAAI+B,GACHD,GAAS,KAAmB,gBAAoB,IAAK,KAAmB,gBAAoB,OAAQ,CACrGjI,MAAO,CACL2I,KAAM,WAERC,EAAG,2OACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,uaACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,0NACY,gBAAoB,OAAQ,CAC3C5I,MAAO,CACL2I,KAAM,WAERC,EAAG,oiBACA,KAAO,GAAkB,gBAAoB,IAAK,OAAQ,KAAQ,GAAmB,gBAAoB,IAAK,OAAQ,KAAQ,GAAmB,gBAAoB,IAAK,OAAQ,KAAQ,GAAmB,gBAAoB,IAAK,OAAQ,KAAQ,GAAmB,gBAAoB,IAAK,OAAQ,KAAQ,GAAmB,gBAAoB,IAAK,OAAQ,KAAQ,GAAmB,gBAAoB,IAAK,OAAQ,KAAQ,GAAmB,gBAAoB,IAAK,OAAQ,KAAQ,GAAmB,gBAAoB,IAAK,OAAQ,KAAS,GAAoB,gBAAoB,IAAK,OAAQ,KAAS,GAAoB,gBAAoB,IAAK,OAAQ,KAAS,GAAoB,gBAAoB,IAAK,OAAQ,KAAS,GAAoB,gBAAoB,IAAK,OAAQ,KAAS,GAAoB,gBAAoB,IAAK,OAAQ,KAAS,GAAoB,gBAAoB,IAAK,QAG74B,IAAI,GAA0B,aAAiBE,ICzClCC,ID0CE,IC1CK,SAAC,GAAoF,IAAnFtL,EAAkF,EAAlFA,MAAOuL,EAA2E,EAA3EA,KAAMC,EAAqE,EAArEA,UAAWC,EAA0D,EAA1DA,WAAYC,EAA8C,EAA9CA,QAAS9K,EAAqC,EAArCA,IAAKC,EAAgC,EAAhCA,IAAKE,EAA2B,EAA3BA,SACzE,OACI,sBAAKwB,MAAO,CACRlD,MAAM,GAAD,OAAKkM,EAAL,MACLI,OAAO,GAAD,OAAKJ,EAAL,MACNK,QAAQ,eACRpJ,WAAW,GAAD,OAAKxC,IACf6L,UAAU,OACVC,YAAa,kBAAMN,EAAU5K,EAAKC,IAClCkL,aAAc,kBAAMN,EAAW7K,EAAKC,IACpCmL,UAAW,kBAAMN,EAAQ9K,EAAKC,IAC7B6H,GAAE,aAAQ9H,EAAR,cAAiBC,GATxB,UAWME,IAAaX,EAASG,OAAS,cAAC,GAAD,CAAKlB,MAAOkM,EAAMI,OAAQJ,IACzDxK,IAAaX,EAASI,KAAO,cAAC,GAAD,CAAOnB,MAAOkM,EAAMI,OAAQJ,SCd1DU,GAAS,SAAC,GAAmF,IAAlFrI,EAAiF,EAAjFA,KAAMsI,EAA2E,EAA3EA,WAAYV,EAA+D,EAA/DA,UAAWC,EAAoD,EAApDA,WAAYC,EAAwC,EAAxCA,QAASS,EAA+B,EAA/BA,aACtE,OACI,cAACC,GAAA,EAAD,CAAKzM,GAAI,CACL0M,OAAQ,EACRxM,WAAY,EACZyM,QAAQ,oCAHZ,SAKK1I,EAAK2I,KAAI,SAAC3L,EAAK4L,GACZ,OACI,qBAAkBjK,MAAO,CAACsG,SAAU,GAApC,SACKjI,EAAI2L,KAAI,SAAC1K,EAAM4K,GACZ,IAAMC,EAAO,CAAC1M,MAAO6B,EAAK7B,MAAOuL,KAAMW,EAAYtL,IAAKiB,EAAKV,OAAOP,IACtDC,IAAKgB,EAAKV,OAAON,IAAK8L,eAAgBR,EACtCV,WAAYA,EAAYC,QAASA,EAASF,UAAWA,EACrDhC,IAAKiD,EAAQ1L,SAAUc,EAAKd,UAC1C,OACI,cAAC,GAAD,gBAAU2L,QAPZF,SCR9B,SAASI,GAAkBC,EAAYC,EAAcC,EAAcC,EAAcC,EAAchK,EAAyBW,GACpH,GAAIiJ,EAAG,CAEH,GAAIE,EAAOD,EAAO,EAAG,OAGrB,IAAMhC,EAA+C,EAA3CoC,KAAKC,MAAMC,GAAaJ,EAAMC,GAAQ,IAkBxD,SAAkBH,EAAcC,EAAcjC,EAAWlH,EAAuBX,GAC5E,IAAMoK,EAAkD,EAA3CH,KAAKC,MAAMC,GAAaN,EAAMC,GAAQ,GAAS,EAC5DnJ,EAAKkH,GAAGuC,GAAMrM,WAAY,EAE1B,IAAK,IAAImC,EAAI2J,EAAM3J,GAAK4J,EAAM5J,IACtBA,IAAMkK,GAASzJ,EAAKkH,GAAG3H,GAAGnC,YAC1B4C,EAAKkH,GAAG3H,GAAG/B,QAAS,EACpB6B,EAAWI,KAAX,MAAAJ,EAAU,YAASF,EAAoBa,EAAKkH,GAAG3H,OAxBnDmK,CAASR,EAAMC,EAAMjC,EAAGlH,EAAMX,GAE9B2J,IAAmBC,EAAGC,EAAMC,EAAMC,EAAMlC,EAAI,EAAG7H,EAAYW,GAC3DgJ,IAAmBC,EAAGC,EAAMC,EAAMjC,EAAI,EAAGmC,EAAMhK,EAAYW,OACxD,CAEH,GAAIqJ,EAAOD,EAAO,EAAG,OAGrB,IAAMnC,EAA+C,EAA3CqC,KAAKC,MAAMC,GAAaN,EAAMC,GAAQ,IAoBxD,SAAkBC,EAAcC,EAAcpC,EAAWjH,EAAuBX,GAC5E,IAAMoK,EAAkD,EAA3CH,KAAKC,MAAMC,GAAaJ,EAAMC,GAAQ,GAAS,EAC5DrJ,EAAKyJ,GAAMxC,GAAG7J,WAAY,EAE1B,IAAK,IAAImC,EAAI6J,EAAM7J,GAAK8J,EAAM9J,IACtBA,IAAMkK,GAASzJ,EAAKT,GAAG0H,GAAG7J,YAC1B4C,EAAKT,GAAG0H,GAAGzJ,QAAS,EACpB6B,EAAWI,KAAX,MAAAJ,EAAU,YAASF,EAAoBa,EAAKT,GAAG0H,OA1BnD0C,CAASP,EAAMC,EAAMpC,EAAGjH,EAAMX,GAE9B2J,IAAmBC,EAAGC,EAAMjC,EAAE,EAAGmC,EAAMC,EAAMhK,EAAYW,GACzDgJ,IAAmBC,EAAGhC,EAAI,EAAGkC,EAAMC,EAAMC,EAAMhK,EAAYW,IA4CnE,SAASwJ,GAAaI,EAAaC,GAC/B,OAAOP,KAAKC,MAAMD,KAAKQ,UAAYD,EAAMD,EAAM,GAAKA,GC1DjD,SAASG,GAAsBH,EAAaC,GAE/C,OAAOP,KAAKC,MAAMD,KAAKQ,UAAYD,EAAMD,EAAM,GAAKA,GCwBxD,SAASI,GAAoB5I,EAA0BpB,GACnD,OA6EG,SAA0BoB,EAA0BpB,GAEvD,IAAMqB,EAAoB,GAGtBrE,EAAMoE,EAAQ7D,OAAOP,IAAM,EAC3BC,EAAMmE,EAAQ7D,OAAON,IACtBqE,EAAgBtE,EAAKC,EAAK+C,IACzBqB,EAAM5B,KAAK,CAAC3B,OAAQ,IAAIH,EAAgBqC,EAAKhD,GAAKC,GAAKE,SAAUH,EAAKC,GAC1DY,KAAM,IAAIF,EAAgBqC,EAAKhD,EAAM,GAAGC,GAAKE,SAAUH,EAAM,EAAGC,KAGhFD,EAAMoE,EAAQ7D,OAAOP,IACrBC,EAAMmE,EAAQ7D,OAAON,IAAM,EACxBqE,EAAgBtE,EAAKC,EAAK+C,IACzBqB,EAAM5B,KAAK,CAAC3B,OAAQ,IAAIH,EAAgBqC,EAAKhD,GAAKC,GAAKE,SAAUH,EAAKC,GAClEY,KAAM,IAAIF,EAAgBqC,EAAKhD,GAAKC,EAAM,GAAGE,SAAUH,EAAKC,EAAM,KAI1ED,EAAMoE,EAAQ7D,OAAOP,IAAM,EAC3BC,EAAMmE,EAAQ7D,OAAON,IAClBqE,EAAgBtE,EAAKC,EAAK+C,IACzBqB,EAAM5B,KAAK,CAAC3B,OAAQ,IAAIH,EAAgBqC,EAAKhD,GAAKC,GAAKE,SAAUH,EAAKC,GAClEY,KAAM,IAAIF,EAAgBqC,EAAKhD,EAAM,GAAGC,GAAKE,SAAUH,EAAM,EAAGC,KAIxED,EAAMoE,EAAQ7D,OAAOP,IACrBC,EAAMmE,EAAQ7D,OAAON,IAAM,EACxBqE,EAAgBtE,EAAKC,EAAK+C,IACzBqB,EAAM5B,KAAK,CAAC3B,OAAQ,IAAIH,EAAgBqC,EAAKhD,GAAKC,GAAKE,SAAUH,EAAKC,GAClEY,KAAM,IAAIF,EAAgBqC,EAAKhD,GAAKC,EAAM,GAAGE,SAAUH,EAAKC,EAAK,KAIzE,OAAOoE,EAjHA4I,CAAiB7I,EAASpB,GAAMG,QAAO,SAAA+J,GAAQ,OAAKA,EAASpM,OAAOqM,eAS/E,SAASC,GAAWC,EAAiCjJ,EAA0B8I,EAC3D7K,EAAyBW,GAGzC,If4BkC/B,Ee5B5BqM,EAAoBP,GAAsB,EAAGG,EAAS1K,OAAS,GAC/D+K,EAAoBL,EAASI,GAGnCtK,EAAKuK,EAAQzM,OAAOP,OAAOP,KAAKuN,EAAQzM,OAAOP,OAAON,KAAKuN,UAE3DD,EAAQzM,OAAOqM,YAGf9K,EAAWI,KAAX,MAAAJ,EAAU,afmBwBpB,EenBOsM,EAAQ1M,KfoB1C,CAAC,IAAIiB,EAAUf,EAAcU,UAAWR,GAAO,IAAIa,EAAUJ,EAAMhC,MAAOuB,OenBjFsM,EAAQ1M,KAAKL,QAAS,EACtBwC,EAAKuK,EAAQ1M,KAAKN,OAAOP,KAAKuN,EAAQ1M,KAAKN,OAAON,KAAKO,QAAS,EAIhE,IAAI,IAAI+B,EAAI,EAAGA,EAAI2K,EAAS1K,OAAQD,KASpC8K,EAAa5K,KAAK8K,EAAQzM,QCxD9B,SAAS2M,GAAUzN,EAAaC,EAAa+C,GACzC,IADyE,EAErE0K,EAAY,EAFyD,cd4EtE,SAAwBtJ,EAAsBpB,GACjD,IAAMqB,EAAuBF,EAAYC,EAASpB,GAI9ChD,EAAMoE,EAAQ7D,OAAOP,IAAM,EAC3BC,EAAMmE,EAAQ7D,OAAON,IAAM,EAsB/B,OArBGqE,EAAgBtE,EAAKC,EAAK+C,IACzBqB,EAAM5B,KAAKO,EAAKhD,GAAKC,IAKtBqE,EAFHtE,EAAMoE,EAAQ7D,OAAOP,IAAM,EAC3BC,EAAMmE,EAAQ7D,OAAON,IAAM,EACE+C,IACzBqB,EAAM5B,KAAKO,EAAKhD,GAAKC,IAKtBqE,EAFHtE,EAAMoE,EAAQ7D,OAAOP,IAAM,EAC3BC,EAAMmE,EAAQ7D,OAAON,IAAM,EACE+C,IACzBqB,EAAM5B,KAAKO,EAAKhD,GAAKC,IAKtBqE,EAFHtE,EAAMoE,EAAQ7D,OAAOP,IAAM,EAC3BC,EAAMmE,EAAQ7D,OAAON,IAAM,EACE+C,IACzBqB,EAAM5B,KAAKO,EAAKhD,GAAKC,IAElBoE,EcnG4BsJ,CAAe3K,EAAKhD,GAAKC,GAAM+C,IALO,IAKzE,IAAI,EAAJ,qBAAyE,SACzDxC,QACRkN,KAPiE,8BAUzE,OAAOA,EAAY,EChCvB,IAyBaE,GAAb,WAUI,WAAYvL,EAA8B6C,EAAcC,GAAe,yBAJvD9C,gBAIsD,OAHtD6C,UAGsD,OAFtDC,UAEsD,EAClE1F,KAAK4C,WAAaA,EAClB5C,KAAKyF,KAAOA,EACZzF,KAAK0F,KAAOA,EAbpB,0CAgBI,WACI,MAAO,OAjBf,KAAayI,GACFC,KAAO,IAAID,IF3Bf,SAA4B5K,EAAuBa,EAAcC,GAEpE,IAAMzB,EAA0B,GAC5BgL,EAAkC,GAUtC,KAqFJ,SAAkCrK,GAG9B,IAFA,IAAMX,EAAa,GAEVE,EAAI,EAAGA,EAAIS,EAAKR,OAAS,EAAGD,IACjC,IAAK,IAAIuL,EAAI,EAAGA,EAAI9K,EAAK,GAAGR,OAAS,EAAGsL,KACjCvL,EAAI,IAAM,GAAMuL,EAAI,IAAM,GAAKvL,EAAI,IAAM,KACxCF,EAAWI,KAAX,MAAAJ,EAAU,YAASF,EAAoBa,EAAKT,GAAGuL,MAC/C9K,EAAKT,GAAGuL,GAAGtN,QAAS,GAExBwC,EAAKT,GAAGuL,GAAGC,YAInB1L,EAAWsJ,KAAI,SAAAqC,GAAS,OAAIA,EAAUhM,WAxGtCiM,CAAyBjL,GAGzBqK,EAAa5K,KAAK,IAAI9B,EAAgBqC,EAAK,GAAG,GAAG7C,SAAU,EAAG,IAG/B,IAAxBkN,EAAa7K,QAAc,CAG9B,IAAM4B,EAAuCiJ,EAAaa,MAC1D,QAAepJ,IAAZV,EAAuB,MAAO,GAGjC,IAAM+J,EAA4BnB,GAAoB5I,EAASpB,GAE/D4C,QAAQC,IAAIuI,KAAKC,MAAMD,KAAKE,UAAUlK,KACtCwB,QAAQC,IAAIuI,KAAKC,MAAMD,KAAKE,UAAUH,KAIlCA,EAAc3L,OAAS,GACnB4K,GAAWC,EAAcjJ,EAAS+J,EAAe9L,EAAYW,GAIzE,OAAOX,IELoC,OA1BjC,yQAyBDuL,GAEFW,OAAS,IAAIX,IAAK,iBAAM,KAAI,SArBnB,4IAmBPA,GAGFY,OAAS,IAAIZ,IDhCjB,SAAiC5K,EAAuBa,EAAcC,GAEzE,IAAMzB,EAA0B,GAC1BoM,EAsCV,SAA0BzL,GAItB,IAHA,IAAMqB,EAAQ,GAGN9B,EAAI,EAAGA,EAAIS,EAAKR,OAAQD,IAC5B,IAAI,IAAIuL,EAAI,EAAGA,EAAI9K,EAAK,GAAGR,OAAQsL,IAG/BzJ,EAAM5B,KAAK,CAACF,EAAGuL,IAOvB,OAAOzJ,EArDeqK,CAAiB1L,GAGvC,KAqDJ,SAAiB2L,GACb,IAAkCC,EAA9BC,EAAeF,EAAMnM,OAGzB,KAAwB,IAAjBqM,GAAoB,CAGvBD,EAActC,KAAKC,MAAMD,KAAKQ,SAAW+B,GACzCA,IAJuB,MAOqB,CACxCF,EAAMC,GAAcD,EAAME,IAD7BF,EAAME,GAPgB,KAODF,EAAMC,GAPL,MA3D3BE,CAAQL,GAEwB,IAAzBA,EAAcjM,QAAc,CAE/B,MAAmBiM,EAAcP,MAAjC,mBAAOlO,EAAP,KAAYC,EAAZ,KAEGwN,GAAUzN,EAAKC,EAAK+C,KAEnBX,EAAWI,KAAX,MAAAJ,EAAU,YAASF,EAAoBa,EAAKhD,GAAKC,MAEjD+C,EAAKhD,GAAKC,GAAKO,QAAS,GAMhC,OAAO6B,ICY4C,SARnC,4NAKPuL,GAIFmB,iBAAmB,IAAInB,IJjC3B,SAA8B5K,EAAuBa,EAAcC,GACtE,IAAMzB,EAA0B,GAMhC,OAoDJ,SAAoBW,EAAuBX,GACvC,IAAK,IAAIE,EAAI,EAAGA,EAAIS,EAAKR,OAAQD,IAC7B,GAAU,IAANA,GAAWA,IAAOS,EAAKR,OAAS,EAChC,IAAK,IAAIsL,EAAI,EAAGA,EAAI9K,EAAK,GAAGR,OAAQsL,IAChC9K,EAAKT,GAAGuL,GAAGtN,QAAS,EACpB6B,EAAWI,KAAX,MAAAJ,EAAU,YAASF,EAAoBa,EAAKT,GAAGuL,WAGnD9K,EAAKT,GAAG,GAAG/B,QAAS,EACpB6B,EAAWI,KAAX,MAAAJ,EAAU,YAASF,EAAoBa,EAAKT,GAAG,MAE/CS,EAAKT,GAAGS,EAAK,GAAGR,OAAS,GAAGhC,QAAS,EACrC6B,EAAWI,KAAX,MAAAJ,EAAU,YAASF,EAAoBa,EAAKT,GAAGS,EAAK,GAAGR,OAAS,MApExEwM,CAAWhM,EAAMX,GAEjB2J,IAAkB,EAAM,EAAGhJ,EAAK,GAAGR,OAAS,EAAG,EAAGQ,EAAKR,OAAS,EAAGH,EAAYW,GAExEX,II0BkD,YAjBlC,kUCEpB,IAAM4M,GAAY,SAAC,GAAwD,IAAvDxQ,EAAsD,EAAtDA,MAAOC,EAA+C,EAA/CA,QAASC,EAAsC,EAAtCA,OAAQuQ,EAA8B,EAA9BA,aAEzC/H,EAAW,CAAChI,gBrBhBI,mBqBgByBV,MAAe,IAARA,GAChD4I,EAAYC,iBAAO,MAEnBC,EAAmB,SAAC4H,GAEtB9H,EAAUjD,QAAQqD,QAClB/I,EAAQyQ,IAGZ,OACI,cAACrJ,EAAA,EAAD,CAAO4B,UAAU,SAASjJ,MAAOA,EAAOQ,WAAY,EAApD,SACI,eAAC0I,EAAA,EAAD,CAAW5I,GAAI,CACXI,gBAAiBlB,EACjBmB,MAAOjB,EACPa,aAAc,GACfO,SAAUZ,EAJb,UAKI,eAACiJ,EAAA,EAAD,CACIC,WAAY,cAAC,KAAD,CAAgB9I,GAAI,CAACK,MAAOjB,KACxC,gBAAc,kBACd2J,GAAG,iBACH/I,GAAI,CAACC,aAAc,GAAI+I,IAAKV,EAJhC,UAKI,cAACW,EAAA,EAAD,CAAY3I,WAAW,OAAO4I,SAAU,GAAxC,oBACA,eAACD,EAAA,EAAD,CAAYE,YAAa,EAAGD,SAAU,GAAtC,eAA6CiH,EAAahK,WAE9D,cAACiD,EAAA,EAAD,CAAkBpJ,GAAI,CAACC,aAAc,GAArC,SACI,eAACJ,EAAA,EAAD,CACIC,YAAY,WACZ,aAAW,kCACXC,QAAQ,YACRC,GAAI,CAACqJ,UAAW,GAJpB,UAKI,cAAClJ,EAAA,EAAD,CAAQH,GAAIoI,EAAU7H,QAAS,kBAAMiI,EAAiBqG,GAAKmB,mBAA3D,wBACA,cAAC7P,EAAA,EAAD,CAAQH,GAAIoI,EAAU7H,QAAS,kBAAMiI,EAAiBqG,GAAKW,SAA3D,sBACA,cAACrP,EAAA,EAAD,CAAQH,GAAIoI,EAAU7H,QAAS,kBAAMiI,EAAiBqG,GAAKY,SAA3D,iC,+BC1CXY,GAAc,SAAC,GAA2F,IAA1FC,EAAyF,EAAzFA,SAAUC,EAA+E,EAA/EA,SAAUC,EAAqE,EAArEA,aAAc9Q,EAAuD,EAAvDA,MAAO+Q,EAAgD,EAAhDA,kBAAmB7Q,EAA6B,EAA7BA,OACrF,OACI,eAACmH,EAAA,EAAD,CAAO/G,GAAI,CACPI,gBAAiBjB,EACjBc,aAAc,EACdI,MAAO,SAHX,UAKI,cAAC0G,EAAA,EAAD,UACI,eAACkC,EAAA,EAAD,CAAYF,GAAG,mBAAmB/I,GAAI,CAClC0Q,WAAY,EACZvH,YAAa,EACbwH,YAAa,EACbrQ,WAAY,OACZ2L,QAAS,OACT2E,WAAY,SACZC,SAAU,OACV3H,SAAU,IARd,6BAUI,cAAC,KAAD,CAAkBlJ,GAAI,CAACmJ,YAAa,EAAG6C,OAAQ,WAGvD,cAAC8E,GAAA,EAAD,CAAQlF,KAAM,QAASkC,IAAKyC,EAAU1C,IAAKyC,EAAUS,aAAcP,EAAsBxQ,GAAI,CACzFE,WAAY,EACZD,aAAc,EACdP,MAAe,GAARA,EACPW,MtB1BmB,WsB2BpB2Q,SAAUP,EAAmBjQ,SAAUZ,GAL4C,OChC3F,SAASqR,GAAuBhN,EAAuBhD,EAAaC,GACvE,OAAG+C,EAAKhD,GAAKC,GAAKE,WAAaX,EAASG,OAASqD,EAAKhD,GAAKC,GAAKE,WAAaX,EAASI,IAC3E,IAEXoD,EAAKhD,GAAKC,GAAKgQ,SACR9N,EAAoBa,EAAKhD,GAAKC,KCClC,IAAMiQ,GAAc,SAAC,GAAgD,IAA/CzR,EAA8C,EAA9CA,MAAOC,EAAuC,EAAvCA,QAASC,EAA8B,EAA9BA,OACzC,OACI,cAACC,EAAA,EAAD,CACIC,YAAY,WACZ,aAAW,kCACXC,QAAQ,YACRC,GAAI,CAACC,aAAc,GAJvB,SAMI,cAACE,EAAA,EAAD,CAAQH,GAAI,CACRI,gBxBOgB,yBwBNhBC,MAAOjB,EACPkB,WAAY,OACZZ,MAAOA,GAEHa,QAASZ,EAASa,SAAUZ,EANpC,4B,wCCOCwR,GAA0B,SAAC,GAA6C,IAA5C3I,EAA2C,EAA3CA,UAErC,GAFgF,EAAhC/I,MAExB2I,oBAAS,IAAjC,mBAAOgJ,EAAP,KAAaC,EAAb,KAMA,OAJAC,qBAAU,WACND,GAAQ,KACT,CAAC7I,IAIA,cAAC+I,GAAA,EAAD,CAAO7I,UAAU,KAAK8I,GAAIJ,EAAMK,cAAY,EAACC,eAAa,EAA1D,SACI,eAAC5K,EAAA,EAAD,CAAO4B,UAAU,MAAM3I,GAAI,CAACI,gBAAiBnB,GAA7C,UACI,eAACgK,EAAA,EAAD,CAAYjJ,GAAI,CAACK,MAAOjB,EAAWwS,QAAS,EAAGC,aAAc,GAA7D,cAAmEpJ,EAAUrC,KAA7E,OACA,cAAC0L,GAAA,EAAD,CAAMC,KAAK,IAAX,SACI,cAAC,KAAD,CAAWxR,QAAS,kBAAM+Q,GAAQ,IACvBtR,GAAI,CAACK,MAAOjB,EAAWwS,QAAS,EAAGzI,YAAa,GAD3D,uBC1BP6I,GAAqB,SAAC,GAA2C,EAA1CtS,MAA2C,IAApC0Q,EAAmC,EAAnCA,KACvC,EAAwB/H,oBAAS,GAAjC,mBAAOgJ,EAAP,KAAaC,EAAb,KAMA,OAJAC,qBAAU,WACND,GAAQ,KACT,CAAClB,IAIA,cAACoB,GAAA,EAAD,CAAO7I,UAAU,KAAK8I,GAAIJ,EAAMK,cAAY,EAACC,eAAa,EAA1D,SACI,eAAC5K,EAAA,EAAD,CAAQ4B,UAAU,MAAM3I,GAAI,CAACI,gBAAiBlB,GAA9C,UACI,eAAC+J,EAAA,EAAD,CAAYjJ,GAAI,CAAEK,MAAOjB,EAAWwS,QAAS,IAAKC,aAAc,IAAhE,cAAwEzB,EAAKhK,KAA7E,OACA,cAAC0L,GAAA,EAAD,CAAMC,KAAK,IAAX,SACI,cAAC,KAAD,CAAWxR,QAAS,kBAAM+Q,GAAQ,IACvBtR,GAAI,CAACK,MAAOjB,EAAWwS,QAAS,EAAGzI,YAAa,GAD3D,uB,UCAP8I,GAAM,SAAC,GAAuD,IAAtDC,EAAqD,EAArDA,WAAYtN,EAAyC,EAAzCA,QAASC,EAAgC,EAAhCA,KAAM0H,EAA0B,EAA1BA,WAGtC4F,EAAsB,IAC5B,EAA4C9J,mBAAS8J,IAArD,mBAAOC,EAAP,KAAuBC,EAAvB,KAKA,EAAwChK,oBAAS,GAAjD,mBAAOmE,EAAP,KAAqB8F,EAArB,KACA,EAA4BjK,oBAAS,GAArC,mBAAOzI,EAAP,KAAe2S,EAAf,KAIA,EAA8ClK,mBAAS,IAAIrH,EAAMgN,GAAsB,EAAGnJ,EAAO,GAAImJ,GAAsB,EAAGpJ,EAAU,KAAxI,mBAAO4N,EAAP,KAAwBC,EAAxB,KACA,EAA0CpK,mBAAS,IAAIrH,EAAMgN,GAAsB,EAAGnJ,EAAO,GAAImJ,GAAsB,EAAGpJ,EAAU,KAApI,mBAAO8N,EAAP,KAAsBC,EAAtB,KAIA,EAAkDtK,oBAAS,GAA3D,mBAAOuK,EAAP,KAA0BC,EAA1B,KACA,EAA8CxK,oBAAS,GAAvD,mBAAOyK,EAAP,KAAwBC,EAAxB,KAGA,EAAkC1K,mBAASpC,EAAUU,KAArD,mBAAO8B,EAAP,KAAkBuK,EAAlB,KACA,EAAwB3K,mBAASwG,GAAKW,QAAtC,mBAAOY,GAAP,KAAa6C,GAAb,KAGA,GAAgD5K,mBAAS,IAAzD,qBAAOpE,GAAP,MAAaiP,GAAb,MAqFA,SAASC,GAAgB7P,EAAyB8P,GAC9C,IADoE,IAAD,WAC1D5P,GACL6P,YAAW,WACP/P,EAAWE,GAAGP,QACVO,IAAMF,EAAWG,OAAS,IAC1B8O,GAAU,GACVW,GAAQxO,EAAWT,GAAMW,EAASC,EAAM2N,EAAiBE,OAE9DU,EAAQ5P,IAPNA,EAAI,EAAGA,EAAIF,EAAWG,OAAQD,IAAM,EAApCA,GAiBb,OALA+N,qBAAU,WACN2B,GtBjJD,SAAwBtO,EAAiBC,EAAcC,EAAcC,GAGxE,IAFA,IAAMd,EAAO,GAEJhD,EAAM,EAAGA,EAAM4D,EAAM5D,IAAO,CAEjC,IADA,IAAM+D,EAAa,GACV9D,EAAM,EAAGA,EAAM0D,EAAS1D,IAC7B8D,EAAWtB,KAAK,IAAIvC,EAAYV,EAASE,MAAOM,EAAKC,IAEzD+C,EAAKP,KAAKsB,GAMd,OAHAf,EAAKa,EAAM7D,KAAK6D,EAAM5D,KAAO,IAAIC,EAAYV,EAASG,MAAOkE,EAAM7D,IAAK6D,EAAM5D,KAC9E+C,EAAKc,EAAI9D,KAAK8D,EAAI7D,KAAO,IAAIC,EAAYV,EAASI,IAAKkE,EAAI9D,IAAK8D,EAAI7D,KAE7D+C,EsBmIKqP,CAAe1O,EAASC,EAAM2N,EAAiBE,MACxD,IAIC,eAAC3L,EAAA,EAAD,CAAO4B,UAAU,MAAjB,UACI,eAAC5B,EAAA,EAAD,CAAO4B,UAAU,SAAS3I,GAAI,CAACN,MAAOwS,EAAYxF,OAAQ,GAA1D,UAEI,eAAC3F,EAAA,EAAD,CAAO4B,UAAW,MAAlB,UACI,cAAC,GAAD,CAAajJ,MAAOwS,EAAa,EAAGvS,QA5B1B,WACtBuT,GtB1FD,SAAmBvO,EAA0BC,EAAiBC,EAAcC,EAAcC,GAI7F,IAFA,IAAMd,EAAO,GAEJhD,EAAM,EAAGA,EAAM4D,EAAM5D,IAAO,CAEjC,IADA,IAAM+D,EAAa,GACV9D,EAAM,EAAGA,EAAM0D,EAAS1D,IAC1ByD,EAAQ1D,GAAKC,GAAKO,SACjB,IAAIsB,EAAUf,EAAcO,SAAUoC,EAAQ1D,GAAKC,IAAM+B,QACzD,IAAIF,EAAUJ,EAAMhC,MAAOgE,EAAQ1D,GAAKC,IAAM+B,SAElD,IAAIF,EAAUJ,EAAMhC,MAAOgE,EAAQ1D,GAAKC,IAAM+B,QAC9C+B,EAAWtB,KAAK,IAAIvC,EAAYV,EAASE,MAAOM,EAAKC,IAEzD+C,EAAKP,KAAKsB,GAMd,OAHAf,EAAKa,EAAM7D,KAAK6D,EAAM5D,KAAO,IAAIC,EAAYV,EAASG,MAAOkE,EAAM7D,IAAK6D,EAAM5D,KAC9E+C,EAAKc,EAAI9D,KAAK8D,EAAI7D,KAAO,IAAIC,EAAYV,EAASI,IAAKkE,EAAI9D,IAAK8D,EAAI7D,KAE7D+C,EsBsEKsP,CAAUtP,GAAMW,EAASC,EAAM2N,EAAiBE,KA2BmBc,KAAK,IAAO5T,OAAQA,IACnF,cAAC,EAAD,CAAaF,MAAOwS,EAAa,EAAGvS,QAtDpD,WACI4S,GAAU,GAEV,IAAMkB,EAAYxP,GAAKuO,EAAgBvR,KAAKuR,EAAgBtR,KACtDwS,EAAUzP,GAAKyO,EAAczR,KAAKyR,EAAcxR,KAEtDiS,GAAgB1K,EAAUpC,cAAcpC,GAAMwP,EAAWC,GAAUtB,IAgDQoB,KAAK,IAAO5T,OAAQA,OAGvF,cAAC,GAAD,CAAa0Q,SAAUqD,IAA4BpD,SAAU4B,EAChD3B,aAvIK2B,GAuIgCzS,MAAOwS,EAC5CzB,kBAtCI,SAACmD,EAAYC,GACtCxB,EAAkBF,EAAsB0B,IAqCqBL,KAAK,IAAO5T,OAAQA,IAEzE,eAACmH,EAAA,EAAD,CAAO4B,UAAW,MAAlB,UACI,cAAC,GAAD,CAAejJ,MAAOwS,EAAa,EAAGtS,OAAQA,EAAQuI,iBAAkBM,EACzD9I,QAtDC,SAAC8I,GAC7BuK,EAAavK,IAqD+C+K,KAAK,MACrD,cAAC,GAAD,CAAW9T,MAAOwS,EAAa,EAAGvS,QAnDvB,SAACmU,GACrBA,IAAYjF,GAAKW,QAChB+C,GAAU,GAEdY,GAAgBW,EAAQxQ,WAAWW,GAAMuO,EAAiBE,GAAgBN,EAAiB,GAC3Fa,GAAQa,IA8CkEN,KAAK,IAAO5T,OAAQA,EACvEuQ,aAAcC,QAG7B,cAAC,GAAD,CAAyB3H,UAAWA,EAAW/I,MAAOwS,IACtD,cAAC,GAAD,CAAoBxS,MAAOwS,EAAY9B,KAAMA,QAKjD,cAAC,GAAD,CAAQnM,KAAMA,GAAMsI,WAAYA,EAAYR,QAjF9B,SAAC9K,EAAaC,GAChCoR,GAAgB,IAgFuDkB,KAAK,IAChE3H,UA/HQ,SAAC5K,EAAaC,GAClC,IAAItB,EAEJ,OAAIgT,GACAH,EAAmB,IAAIzR,EAAMC,EAAKC,IAClC2R,GAAqB,QACrBK,GAAQxO,EAAWT,GAAMW,EAASC,EAAM,IAAI7D,EAAMC,EAAKC,GAAMwR,KAI7DI,GACAH,EAAiB,IAAI3R,EAAMC,EAAKC,IAChC6R,GAAmB,QACnBG,GAAQxO,EAAWT,GAAMW,EAASC,EAAM2N,EAAiB,IAAIxR,EAAMC,EAAKC,OAI5EoR,GAAgB,GAEZpR,IAAQsR,EAAgBtR,KAAOD,IAAQuR,EAAgBvR,KACvD4R,GAAqB,QACrBK,GAAQjO,EAAyBhB,GAAM,IAAIjD,EAAMC,EAAKC,MAItDA,IAAQwR,EAAcxR,KAAOD,IAAQyR,EAAczR,KACnD8R,GAAmB,QACnBG,GAAQjO,EAAyBhB,GAAM,IAAIjD,EAAMC,EAAKC,WAK1DiS,GAAgBlC,GAAuBhN,GAAMhD,EAAKC,GAAMkR,KA+FjBoB,KAAK,IAAO1H,WA5F9B,SAAC7K,EAAaC,GAC/BtB,IAEAgT,GAAqBE,EACrB,IAAI/P,EAAUf,EAAcM,aAAc2B,GAAKhD,GAAKC,IAAM+B,QACnDuJ,GACP2G,GAAgBlC,GAAuBhN,GAAMhD,EAAKC,GAAMkR,KAsFoBoB,KAAK,IACzEhH,aAAc,kBAAM8F,GAAgB,SAAAyB,GAAS,OAAKA,Y,UC3KhEC,GAAc,CAChB3T,MAAOrB,EACP,UAAW,CACPoB,gBAAiB,OACjBC,MAAO,YAIF4T,GAAe,SAAC,GAA2D,IAA1DhI,EAAyD,EAAzDA,QAASiI,EAAgD,EAAhDA,MAAOxU,EAAyC,EAAzCA,MAAOsM,EAAkC,EAAlCA,OAAQmI,EAA0B,EAA1BA,cAEnDC,EAAW1U,EAAQ,EACnB2U,EAAYrI,EAAS,EAG3B,OAEI,cAACsI,GAAA,EAAD,CACIC,KAAMtI,EACNuI,QAASN,EACT,kBAAgB,oBAChB,mBAAiB,0BAJrB,SAKI,eAACzH,GAAA,EAAD,CAAKzM,GAAI,CACLI,gBAAiBlB,EACjBQ,MAAO0U,EACPpI,OAAQqI,EACRnU,WAAYR,EAAQ,GAAK0U,EAAW,GACpC/K,UAAW2C,EAAS,GAAKqI,EAAY,GACrCzC,QAAS,GANb,UAQI,cAAC3I,EAAA,EAAD,CAAYjJ,GAAI,CACZkJ,SAAU,GACV7I,MAAOrB,EACPsB,WAAY,QAHhB,sBAOA,cAAC2I,EAAA,EAAD,CAAYjJ,GAAI,CACZK,MAAOrB,EACPsB,WAAY,OACZoQ,WAAY,GAHhB,yIASA,eAAC3J,EAAA,EAAD,CAAO4B,UAAU,MAAM3I,GAAI,CAAC0Q,WAAY,GAAxC,UACI,cAACvQ,EAAA,EAAD,CAAQI,QAAS2T,EAAOlU,GAAIgU,GAA5B,qBACA,cAAC7T,EAAA,EAAD,CAAQI,QAAS4T,EAAenU,GAAIgU,GAAapR,MAAO,CAAC1C,WAAYR,EAAQ,GAA7E,gCClDP+U,GAAyB,SAAC,GAAuD,IAAtDxI,EAAqD,EAArDA,QAASiI,EAA4C,EAA5CA,MAAO7K,EAAqC,EAArCA,UACpD,OACI,cAACiL,GAAA,EAAD,CACIC,KAAMtI,EACNuI,QAASN,EACT,kBAAgB,oBAChB,mBAAiB,0BAJrB,SAKQ,eAACnN,EAAA,EAAD,CAAO4B,UAAW,MAAO3I,GAAE,6BAAM0U,IAAN,IAA4BrL,UAAWA,IAAlE,UACA,cAACJ,EAAA,EAAD,CAAYjJ,GAAI2U,GAAhB,oIAIA,cAACxU,EAAA,EAAD,CAAQH,GAAI4U,GAAqBrU,QAAS2T,EAA1C,0BCZHW,GAAwB,SAAC,GAA6D,IAA5D5I,EAA2D,EAA3DA,QAASiI,EAAkD,EAAlDA,MAAO7K,EAA2C,EAA3CA,UACnD,OACI,cAACiL,GAAA,EAAD,CACIC,KAAMtI,EACNuI,QAASN,EACT,kBAAgB,oBAChB,mBAAiB,0BAJrB,SAKI,eAACnN,EAAA,EAAD,CAAO4B,UAAU,MAAM/F,MAAO8R,GACvB1U,GAAI,CAACqJ,UAAWA,GADvB,UAEI,cAACJ,EAAA,EAAD,CAAYjJ,GAAI2U,GAAhB,wJAIA,cAACxU,EAAA,EAAD,CAAQH,GAAI4U,GAAqBrU,QAAS2T,EAA1C,0BCbH9C,GAA0B,SAAC,GAAiE,IAAhEnF,EAA+D,EAA/DA,QAASiI,EAAsD,EAAtDA,MAAO7K,EAA+C,EAA/CA,UACrD,OACI,cAACiL,GAAA,EAAD,CACIC,KAAMtI,EACNuI,QAASN,EACT,kBAAgB,oBAChB,mBAAiB,0BAJrB,SAKI,eAACnN,EAAA,EAAD,CAAO4B,UAAU,MAAM/F,MAAO8R,GACvB1U,GAAI,CAACqJ,UAAWA,GADvB,UAEI,cAACJ,EAAA,EAAD,CAAYjJ,GAAI2U,GAAhB,4IAIA,cAACxU,EAAA,EAAD,CAAQH,GAAI4U,GAAqBrU,QAAS2T,EAA1C,0BCbHY,GAAoB,SAAC,GAAyD,IAAxD7I,EAAuD,EAAvDA,QAASiI,EAA8C,EAA9CA,MAAO7K,EAAuC,EAAvCA,UAC/C,OACI,cAACiL,GAAA,EAAD,CACIC,KAAMtI,EACNuI,QAASN,EACT,kBAAgB,oBAChB,mBAAiB,0BAJrB,SAKI,eAACnN,EAAA,EAAD,CAAO4B,UAAU,MACV3I,GAAE,6BAAM0U,IAAN,IAA2BrL,UAAWA,IAD/C,UAEI,cAACJ,EAAA,EAAD,CAAYjJ,GAAI2U,GAAhB,sOAKA,cAACxU,EAAA,EAAD,CAAQH,GAAI4U,GAAqBrU,QAAS2T,EAA1C,iCCZHU,GAAsB,CAC/BvU,MAAO,OACPqM,OAAQ,EACR,UAAW,CACPtM,gBAAiB,OACjBC,MAAO,YAIFsU,GAAoB,CAC7B/C,QAAS,EACTvR,MAAO,QACPC,WAAY,QAGHoU,GAAsB,CAC/BtU,gBAAiB,UACjBV,MAAO,IACP,cAAe,KAKNqV,GAAW,SAAC,GAAoC,IAAnCjQ,EAAkC,EAAlCA,MAAOkH,EAA2B,EAA3BA,OAE7B,EAA8B3D,mBAAS,GAAvC,mBAAOhD,EAAP,KAAgB2P,EAAhB,KACMC,EAAgB,CAAC,OAAQ,kBAAmB,mBAAoB,UAAY,UAElF1D,qBAAU,WACNyD,EAAWlQ,EAAQ,EAAI,KACxB,CAACA,IAEJ,IAAMoQ,EAAO,WACTF,GAAW,SAAAG,GAAI,OAAIA,EAAO,MAG9B,OACI,qCACI,cAAC,GAAD,CAAwBlJ,QAAoC,oBAA3BgJ,EAAc5P,GAAgC6O,MAAOgB,EAAM7L,UAAW2C,EAAS,MAChH,cAAC,GAAD,CAAuBC,QAAoC,qBAA3BgJ,EAAc5P,GAAiC6O,MAAOgB,EAAM7L,UAAW2C,EAAS,KAChH,cAAC,GAAD,CAAyBC,QAAoC,YAA3BgJ,EAAc5P,GAAwB6O,MAAOgB,EAAM7L,UAAW2C,EAAS,KACzG,cAAC,GAAD,CAAmBC,QAAoC,WAA3BgJ,EAAc5P,GAAuB6O,MAAOgB,EAAM7L,UAAW2C,EAAS,WC9CjGoJ,GAAU,WAGnB,IAAMC,EAAmB,SAACC,GACtB,OAAO/H,KAAKgI,MAAMD,GAAO,IAAM,EAAI/H,KAAKgI,MAAMD,GAAO,EAAI/H,KAAKgI,MAAMD,IAIxE,EAAwBE,cAAjBxJ,EAAP,EAAOA,OAAQtM,EAAf,EAAeA,MACTwS,EAAqB,IAARxS,EAGnB,EAA+B2I,oBAAS,GAAxC,mBAAOoN,EAAP,KAAgBC,EAAhB,KACA,EAA0CrN,oBAAS,GAAnD,mBAAO8L,EAAP,KAAsBwB,EAAtB,KAKA,EAAqBtN,mBAAS,IAAvBkE,EAAP,oBACM3H,EAAUyQ,EAAyB,KAAR3V,EAAgB6M,GAC3C1H,EAAOwQ,EAA0B,GAATrJ,EAAeO,GAG7C,OACI,qCAEI,cAAC,GAAD,CAAc4H,cAAe,WACzBwB,GAAiB,GACjBD,GAAY,IAEFxB,MAAO,kBAAMwB,GAAY,kBAAM,MAC/BzJ,QAASwJ,EAAS/V,MAAOA,EAAOsM,OAAQA,IAEtD,cAAC,GAAD,CAAUlH,MAAOqP,EAAenI,OAAQA,IAExC,cAAC,GAAD,CAAKkG,WAAYA,EAAYtN,QAASA,EAASC,KAAMA,EAAM0H,WAAYA,QCrCnFqJ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEF5S,SAASC,eAAe,W","file":"static/js/main.aeb7da3e.chunk.js","sourcesContent":["\nexport const solveButtonColor = \"#f38d8d\"\n\nexport const welcomeText = \"rgba(217,223,246,0.99)\";\nexport const algorithmsDropDownColor = \"rgba(123,152,248,0.98)\";\nexport const accordionColorAlgorithms = \"rgba(122,147,227,0.93)\"\n\nexport const mazesDropDownColor = \"rgb(243,141,141)\";\nexport const mazesColor = \"rgb(255,189,177)\"\n\nexport const informationBoxColor = \"rgba(160,180,248,0.98)\"\n\nexport const speedSliderColor =\"#ffbdb1\"   ;\nexport const speedSliderLineColor =\"#ff8181\";\n\nexport const canvasColor =  \"#ffbdb1\";\n\nexport const fontColor = \"#ffe\";\n\nexport const emptyNodeColor = \"rgb(255,255,255)\"\n\nexport const wallColor = \"rgba(0,29,101,0.98)\"\n\nexport const shortestPathColor = \"#6b1eff\"\n\nexport const clearButtonColor = \"rgba(123,152,248,0.98)\"\n\nexport const unreachableColor = \"#d21d1d\"","import {Button, ButtonGroup} from \"@mui/material\";\nimport {fontColor, solveButtonColor} from \"../colors\";\n\ninterface solveButtonProps {\n    width: number,\n    clicked: () => any,\n    isBusy: boolean\n}\n\nexport const SolveButton = ({width, clicked, isBusy}: solveButtonProps) => {\n    return(\n        <ButtonGroup\n            orientation=\"vertical\"\n            aria-label=\"vertical contained button group\"\n            variant=\"contained\"\n        sx={{marginBottom: 1, marginLeft: 1}}>\n\n        <Button sx={{\n            backgroundColor: solveButtonColor,\n            color: fontColor,\n            fontWeight: \"bold\",\n            width: width * 0.95,\n        }}\n        onClick={clicked} disabled={isBusy}>\n            SOLVE MAZE\n        </Button>\n\n        </ButtonGroup>\n    );\n}","import {emptyNodeColor} from \"../../components/colors\";\n\nexport class NodeType {\n\n    static Empty: NodeType = new NodeType(emptyNodeColor)\n    static Start: NodeType = new NodeType(emptyNodeColor)\n    static End: NodeType = new NodeType(emptyNodeColor)\n    static Wall: NodeType = new NodeType(\"rgba(3,30,101,0.98)\")\n    static None: NodeType = new NodeType(\"\")\n\n    public color: string\n\n\n    constructor(color: string) {\n        this.color = color;\n\n    }\n}\n\nexport class Point {\n    public row: number\n    public col: number\n\n    constructor(row: number, col: number) {\n        this.col = col\n        this.row = row\n    }\n}\n\n\n\nexport class NodeBackEnd {\n\n    static None = new NodeBackEnd(NodeType.None, -1, -1)\n\n    public nodeType: NodeType\n    public isVisited: boolean\n    public distance: number\n    public previous: NodeBackEnd\n    public coords: Point\n    public isWall: boolean\n    public color: string\n    public parent: string\n\n    constructor(nodeType: NodeType, row: number, col: number) {\n        this.parent = \"\"\n        this.nodeType = nodeType\n        this.isVisited = false\n        this.distance = Infinity\n        this.previous =  NodeBackEnd.None\n        this.coords = new Point(row, col)\n        this.isWall = nodeType === NodeType.Wall\n        this.color = nodeType.color\n    }\n\n    toggle() {\n        this.isWall = true\n        return this\n    }\n\n    visitedIs() {\n        return this.isVisited\n    }\n\n    visited() {\n        this.isVisited = true\n    }\n\n    unVisited() {\n        this.isVisited = false\n    }\n\n}\n\n\nexport interface Adjacent {\n    edge: MazeNodeBackEnd,\n    vertex: MazeNodeBackEnd,\n}\n\nexport class MazeNodeBackEnd extends NodeBackEnd {\n\n    static None = new MazeNodeBackEnd(NodeType.None, -1, -1)\n\n    public previousAdjacent: Adjacent\n\n\n    constructor(nodeType: NodeType, row: number, col: number) {\n        super(nodeType, row, col)\n        this.previousAdjacent = {edge: MazeNodeBackEnd.None, vertex: MazeNodeBackEnd.None}\n    }\n\n}\n\n\nexport class AStarNode extends NodeBackEnd{\n\n    public g: number\n    public f: number\n    public h: number\n    public closed: boolean\n\n    constructor(node: NodeBackEnd) {\n        super(node.nodeType, node.coords.row, node.coords.col);\n        this.g = this.f = this.h = 0\n        this.closed = false\n    }\n\n}","import {NodeBackEnd, NodeType} from \"../grid/NodeEngine\";\n\nimport './AnimationsEngine.css'\nimport {\n    emptyNodeColor,\n    shortestPathColor,\n    solveButtonColor,\n    speedSliderColor, unreachableColor,\n    wallColor\n} from \"../../components/colors\";\n\n\nexport class AnimationType {\n    static ReachedNode: AnimationType = new AnimationType(8000, solveButtonColor)\n    static SelectedNode: AnimationType = new AnimationType(1000, speedSliderColor)\n    static WallNode: AnimationType = new AnimationType(100, wallColor)\n    static ShortesPathNode: AnimationType = new AnimationType(8000, shortestPathColor)\n    static Unreachable: AnimationType = new AnimationType(1000, unreachableColor)\n    static EmptyNode: AnimationType = new AnimationType(100, emptyNodeColor)\n\n    private readonly duration: number\n    private readonly color: string\n\n    constructor(duration: number, color: string) {\n        this.duration = duration\n        this.color = color\n    }\n\n    apply(node: any) {\n        node.animate(\n           {backgroundColor: [this.color, emptyNodeColor], scale: [0.3, 1]}\n        , this.duration)\n    }\n}\n\nexport class Color {\n    static Wall: Color = new Color(wallColor)\n    static ShortestPath: Color = new Color(shortestPathColor)\n    static Empty: Color = new Color(emptyNodeColor)\n    static Unreachable: Color = new Color(unreachableColor)\n\n    private readonly color: string\n\n    constructor(color: string) {\n        this.color = color\n    }\n\n    apply(node: any) {\n        node.style.background = this.color\n    }\n}\n\nexport class ImageAnimation {\n\n    private type: NodeType\n    private node: NodeBackEnd\n\n    constructor(type: NodeType, node: NodeBackEnd) {\n        this.node = node\n        this.type = type\n    }\n\n    apply() {\n        // @ts-ignore\n        document.getElementById(`row${this.node.coords.row}col${this.node.coords.col}`).appendChild(this.type.imgs[0])\n    }\n\n}\n\nexport class Animation {\n\n    private type: AnimationType | Color\n    public node: NodeBackEnd\n\n    constructor(type: AnimationType | Color, node: NodeBackEnd) {\n        this.type = type\n        this.node = node\n    }\n\n    apply() {\n        // @ts-ignore\n        this.type.apply(document.getElementById(`row${this.node.coords.row}col${this.node.coords.col}`))\n    }\n\n}\n\nexport function toggleWallAnimation(node: NodeBackEnd) {\n    return [new Animation(AnimationType.WallNode, node), new Animation(Color.Wall, node)]\n}\n\nexport function untoggleWallAnimation(node: NodeBackEnd) {\n    return [new Animation(AnimationType.EmptyNode, node), new Animation(Color.Empty, node)]\n}\n\nexport function noSolutionAnimations(animations: Animation[]): Animation[] {\n\n    const noSolutionsAnimations: Animation[] = []\n\n    for (let i = 0; i < animations.length; i++) {\n       noSolutionsAnimations.push(new Animation(AnimationType.Unreachable, animations[i].node))\n       noSolutionsAnimations.push(new Animation(Color.Unreachable, animations[i].node))\n    }\n\n    return noSolutionsAnimations\n}","import {NodeBackEnd, NodeType, Point} from \"../grid/NodeEngine\";\nimport {Animation, AnimationType, noSolutionAnimations} from \"../animations/AnimationsEngine\";\n\nexport function getDijkstraAnimations(grid: NodeBackEnd[][], start: NodeBackEnd, end: NodeBackEnd): Animation[] {\n\n    let animations: Animation[] = []\n    start.distance = 0\n    const unvisitedNodes = getAllNodes(grid)\n    //const unvisitedNodesHeap = new BinaryHeap((node: any) => node.distance)\n    //pushAllNodes(grid, unvisitedNodesHeap)\n\n    while (!!unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes)\n\n        const closestNode: NodeBackEnd | undefined = unvisitedNodes.shift()\n        if(closestNode === undefined) return []\n\n        //If the closest node is a wall then we continue with next closes\n        if (closestNode.isWall) continue\n\n        //If the closest node is at infinity, then we trapped so we stop.\n        if (closestNode.distance === Infinity) return animations.concat(...noSolutionAnimations(animations))\n\n        closestNode.isVisited = true\n        animations.push(new Animation(AnimationType.ReachedNode, closestNode))\n\n        updateUnvisitedNeighbors(closestNode, grid);\n\n        //If we reached the end then we really done!\n        if (closestNode.coords.row === end.coords.row && closestNode.coords.col === end.coords.col)\n            return animations.concat(...getShortestPathAnimation(end));\n    }\n\n    return []\n}\n\nfunction sortNodesByDistance(unvisitedNodes: NodeBackEnd[]) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node: NodeBackEnd, grid: NodeBackEnd[][]) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previous = node;\n    }\n}\n\nfunction getUnvisitedNeighbors(node: NodeBackEnd, grid: NodeBackEnd[][]) {\n    const neighbors = [];\n    const [row, col] = [node.coords.row, node.coords.col];\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid: NodeBackEnd[][]): NodeBackEnd[] {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction pushAllNodes(grid: NodeBackEnd[][], heap: any): void {\n    for (let col = 0; col < grid.length; col++)\n        for (let row = 0; row < grid[0].length; row++)\n            heap.push(grid[row][col]);\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\n// We just traverse from the back up until the start node\nexport function getShortestPathAnimation(finishNode: NodeBackEnd): Animation[] {\n    const animations: Animation[] = [];\n    let currentNode = finishNode;\n\n    while (currentNode.nodeType !== NodeType.None) {\n        animations.push(new Animation(AnimationType.ShortesPathNode, currentNode));\n        currentNode = currentNode.previous;\n    }\n\n    return animations;\n}\n","import {NodeBackEnd, NodeType, Point} from \"./NodeEngine\";\nimport {emptyNodeColor} from \"../../components/colors\";\nimport {re} from \"mathjs\";\n\nimport {AnimationType, Animation, Color, ImageAnimation} from \"../animations/AnimationsEngine\";\n\nexport function initializeGrid(columns: number, rows: number, start: Point, end: Point) {\n    const grid = []\n\n    for (let row = 0; row < rows; row++) {\n        const currentRow = [];\n        for (let col = 0; col < columns; col++) {\n            currentRow.push(new NodeBackEnd(NodeType.Empty, row, col));\n        }\n        grid.push(currentRow);\n    }\n\n    grid[start.row][start.col] = new NodeBackEnd(NodeType.Start, start.row, start.col)\n    grid[end.row][end.col] = new NodeBackEnd(NodeType.End, end.row, end.col)\n\n    return grid;\n}\n\nexport function updateGrid(oldGrid: readonly NodeBackEnd[][], columns: number, rows: number, start: Point, end: Point) {\n    const grid = []\n\n    for (let row = 0; row < rows; row++) {\n        const currentRow = [];\n        for (let col = 0; col < columns; col++) {\n           if(oldGrid[row][col].isWall)\n               currentRow.push(new NodeBackEnd(NodeType.Wall, row, col));\n           else\n               currentRow.push(new NodeBackEnd(NodeType.Empty, row, col));\n        }\n        grid.push(currentRow);\n    }\n\n    grid[start.row][start.col] = new NodeBackEnd(NodeType.Start, start.row, start.col)\n    grid[end.row][end.col] = new NodeBackEnd(NodeType.End, end.row, end.col)\n\n    return grid;\n}\n\nexport function clearGrid(oldGrid: NodeBackEnd[][], columns: number, rows: number, start: Point, end: Point) {\n\n    const grid = []\n\n    for (let row = 0; row < rows; row++) {\n        const currentRow = [];\n        for (let col = 0; col < columns; col++) {\n            if(oldGrid[row][col].isWall) {\n                new Animation(AnimationType.WallNode, oldGrid[row][col]).apply()\n                new Animation(Color.Empty, oldGrid[row][col]).apply()\n            }\n            new Animation(Color.Empty, oldGrid[row][col]).apply(); //We clear the colored nodes when didn't found end\n            currentRow.push(new NodeBackEnd(NodeType.Empty, row, col));\n        }\n        grid.push(currentRow);\n    }\n\n    grid[start.row][start.col] = new NodeBackEnd(NodeType.Start, start.row, start.col)\n    grid[end.row][end.col] = new NodeBackEnd(NodeType.End, end.row, end.col)\n\n    return grid;\n\n}\n\nexport function removeStartEndCoordinate(grid: NodeBackEnd[][], start: Point) {\n    const newGrid = grid.slice()\n    newGrid[start.row][start.col] = new NodeBackEnd(NodeType.Empty, start.row, start.col)\n    return newGrid\n}\n\n//Really should be a better way, but thought had a major bug in the algorithm\n//when building BFS and it was just this javascript working weird with arrays\nexport function getAdjacent(current: NodeBackEnd, grid: NodeBackEnd[][]): NodeBackEnd[] {\n\n    const nodes: NodeBackEnd[] = []\n\n    //UP\n    let row = current.coords.row - 1\n    let col = current.coords.col\n    if(validCoordinate(row, col, grid))\n        nodes.push(grid[row][col])\n\n    //LEFT\n    row = current.coords.row\n    col = current.coords.col - 1\n    if(validCoordinate(row, col, grid))\n        nodes.push(grid[row][col])\n\n    //DOWN\n    row = current.coords.row + 1\n    col = current.coords.col\n    if(validCoordinate(row, col, grid))\n        nodes.push(grid[row][col])\n\n    //RIGHT\n    row = current.coords.row\n    col = current.coords.col + 1\n    if(validCoordinate(row, col, grid))\n        nodes.push(grid[row][col])\n\n    return nodes\n}\n\nexport function getAllAdjacent(current: NodeBackEnd, grid: NodeBackEnd[][]): NodeBackEnd[] {\n    const nodes: NodeBackEnd[] = getAdjacent(current, grid)\n\n\n    //UP-LEFT\n    let row = current.coords.row - 1\n    let col = current.coords.col - 1\n    if(validCoordinate(row, col, grid))\n        nodes.push(grid[row][col])\n\n    //DOWN-LEFT\n    row = current.coords.row + 1\n    col = current.coords.col - 1\n    if(validCoordinate(row, col, grid))\n        nodes.push(grid[row][col])\n\n    //DOWN-RIGHT\n    row = current.coords.row + 1\n    col = current.coords.col + 1\n    if(validCoordinate(row, col, grid))\n        nodes.push(grid[row][col])\n\n    //UP-RIGHT\n    row = current.coords.row - 1\n    col = current.coords.col + 1\n    if(validCoordinate(row, col, grid))\n        nodes.push(grid[row][col])\n\n    return nodes\n}\n\nexport function validCoordinate(row: number, col: number, grid: NodeBackEnd[][]): boolean {\n    return !(row >= grid.length || row < 0 || col >= grid[0].length || col < 0)\n}\n","import {NodeBackEnd} from \"../grid/NodeEngine\";\nimport {Animation, AnimationType, noSolutionAnimations} from \"../animations/AnimationsEngine\";\nimport {getAdjacent} from \"../grid/GridEngine\";\nimport {getShortestPathAnimation} from \"./Dijkstra\";\nimport {Stack} from \"datastructures-js\";\nrequire('algorithms/data_structures');\n\nexport function getDfsAnimations(grid: NodeBackEnd[][], start: NodeBackEnd, end: NodeBackEnd): Animation[] {\n\n    console.log('dfs called')\n\n    const animations: Animation[] = [new Animation(AnimationType.ReachedNode, start)]\n    const stack: any = new Stack()\n\n    stack.push(start)\n\n    recursiveDfs(grid, start, end, animations)\n\n    return  animations.concat(...getShortestPathAnimation(end.previous))\n}\n\nfunction recursiveDfs(grid: NodeBackEnd[][], current: NodeBackEnd, end: NodeBackEnd, animations: Animation[]): void {\n    grid[current.coords.row][current.coords.col].isVisited = true\n    animations.push(new Animation(AnimationType.ReachedNode, current))\n\n    // @ts-ignore\n    for (const neighbour: NodeBackEnd of getAdjacent(current, grid)) {\n\n        if(neighbour.coords.col === end.coords.col && neighbour.coords.row === end.coords.row) {\n            end.isVisited = true\n            end.previous = current;\n            return;\n        }\n\n        if (!neighbour.isVisited && !neighbour.isWall && !end.isVisited) {\n            recursiveDfs(grid, neighbour, end, animations)\n            neighbour.previous = current\n        }\n    }\n}\n\n/*\n\n    while(!stack.isEmpty()) {\n        const current = stack.pop()\n\n        if(!current.isVisited)\n            animations.push(new Animation(AnimationType.ReachedNode, current))\n\n        // @ts-ignore\n        for( const neighbor: NodeBackEnd of getAdjacent(current, grid)) {\n            if(!neighbor.isVisited && !neighbor.isWall)\n                stack.push(neighbor)\n\n\n            if(neighbor.coords.col === end.coords.col && neighbor.coords.row === end.coords.row) {\n                end.isVisited = true\n                end.previous = current;\n                return animations//.concat(...getShortestPathAnimation(end.previous));\n            }\n        }\n    }\n */","import {NodeBackEnd, NodeType} from \"../grid/NodeEngine\";\nimport {Animation, AnimationType, noSolutionAnimations} from \"../animations/AnimationsEngine\";\nimport {getAdjacent} from \"../grid/GridEngine\";\nimport {getShortestPathAnimation} from \"./Dijkstra\";\n\n/* Returns a set of animations of the nodes traversed and the shortest path between start and end vertices\n*  using biderectional bfs */\nexport function getBidirectionalBFSAnimations(grid: NodeBackEnd[][], start: NodeBackEnd, end: NodeBackEnd): Animation[] {\n\n    const animations: Animation[] = []\n\n    //We initialise the start queue by pushing the start\n    //node and marking it visited\n    const startQueue: NodeBackEnd[] = []\n    startQueue.push(start)\n    start.isVisited = true\n\n    //Ibid\n    const destQueue: NodeBackEnd[] = []\n    destQueue.push(end)\n    end.isVisited = true\n\n\n    //While we have elements in our queues we run dfs\n    while (startQueue.length !== 0 && destQueue.length !== 0) {\n\n\n        //If bfs() returns true then it found another vertex with the other identifier thus it\n        //should stop\n        if (bfs(\"start\", \"end\", startQueue, grid, animations) || bfs(\"end\", \"start\", destQueue, grid, animations))\n            return animations.concat(...getShortestPathAnimation(start))\n\n    }\n\n\n    //If we reached here then we have no solution\n    return animations.concat(...noSolutionAnimations(animations))\n}\n\n/* Applies an iteration of bfs in the queue given and returns true if it\n* reaches a vertex that has already been visited by the other bfs*/\nfunction bfs(identifier: string, otherIdentifier: string, queue: NodeBackEnd[], grid: NodeBackEnd[][], animations: Animation[]): boolean {\n\n    let current: NodeBackEnd | undefined = queue.shift()\n    if (current === undefined) return false\n\n    animations.push(new Animation(AnimationType.ReachedNode, current))\n\n    for (const vertex of getAdjacent(current, grid)) {\n\n        if (vertex.parent === otherIdentifier) {\n            animations.push(new Animation(AnimationType.ReachedNode, vertex))\n            animations.push(...getShortestPathAnimation(vertex))\n            animations.push(...getShortestPathAnimation(current))\n            return true\n        }\n\n        if (!vertex.isVisited && !vertex.isWall) {\n            queue.push(vertex)\n            vertex.isVisited = true\n            vertex.previous = current\n            vertex.parent = identifier\n        }\n    }\n\n    return false\n}\n\n\n\n","import {Animation} from \"../../animations/AnimationsEngine\";\nimport {getDijkstraAnimations} from \"../Dijkstra\";\nimport {NodeBackEnd, Point} from \"../../grid/NodeEngine\";\nimport {getAstarAnimations} from \"../A*\";\nimport {getBfsAnimations} from \"../BFS\";\nimport {getDfsAnimations} from \"../DFS\";\nimport {getBidirectionalBFSAnimations} from \"../BiderectionalBfs\";\n\ntype getAnimationType = (grid: NodeBackEnd[][], startNode: NodeBackEnd, endNode: NodeBackEnd) => Animation[]\n\nconst dijkstraText =\n    `\n     Dijkstra's picks the unvisited vertex with the lowest distance (closest vertex), calculates\n     the distance through it to each unvisited neighbor, and updates the \n     neighbor's distance if smaller. It repeats this until it finds the end-node.\n    Its complexity varies upon the way we store the closest nodes, being the best one\n    O(lgV*V + E) where V are the vertices and E the edges. It works with WEIGHTED graphs\n    `\n\nconst AstarText = ``\n\nconst BfsText =\n`\n    Breadth First Search (BFS) is set to initialise at a vertex and then moves on to traverse all the nodes\n    with the current height before traversing all the others with next depth level. Because in the worst case\n    it traverses the whole graph, its complexity is O(V + E) where V are the vertices and E are the edges \n    of the graph. It works with UN-WEIGHTED graphs\n`\n\nconst DfsText =\n`\n    Depth First Search (DFS) works analogously to BFS but traverses in order of the deepest vertex possible at every\n    step, before reaching it and backtracking. Like BFS it works with UN-WEIGHTED graphs, and traverses the whole\n    graph in worst case so its complexity is O(V + E). Contrary to BFS, it DOESN'T GUARANTEE shortest path\n`\n\nconst BidirectionalBFSText =\n`\n   Bidirectional BFS works by running two BFS simultaneously, one starting from the dog and another starting\n   from the steak. It has the same limitations and BFS but in practise it's usually quite faster due to reducing\n   the total number of traversed vertices. \n`\n\nexport class Algorithm {\n\n    static Dijkstra = new Algorithm(getDijkstraAnimations, \"Dijkstra\", dijkstraText)\n    static Astar = new Algorithm(getAstarAnimations, \"A*\", AstarText)\n    static Bfs = new Algorithm(getBfsAnimations, \"BFS\", BfsText)\n    static Dfs = new Algorithm(getDfsAnimations, \"DFS\", DfsText)\n    static BidirectionalBFS = new Algorithm(getBidirectionalBFSAnimations, \"BFS*\", BidirectionalBFSText)\n\n    public readonly getAnimations: getAnimationType\n    public readonly name: string\n    public readonly text: string\n\n    constructor(getAnimation: any, name: string, text: string) {\n        this.getAnimations = getAnimation\n        this.name = name\n        this.text = text\n    }\n\n}\n\n\n","import {AStarNode, NodeBackEnd} from \"../grid/NodeEngine\";\nimport {Animation, noSolutionAnimations} from \"../animations/AnimationsEngine\";\nimport {getShortestPathAnimation} from \"./Dijkstra\";\nimport {getAdjacent} from \"../grid/GridEngine\";\n\nexport function getAstarAnimations(grid: NodeBackEnd[][], start: NodeBackEnd, end: NodeBackEnd): Animation[] {\n\n    //const openList:\n\n    return []\n}\n\n/*\nfunction AStar(grid: NodeBackEnd[][], start: NodeBackEnd, end: NodeBackEnd, animations: Animation[]) {\n\n    let openHeap = new BinaryHeap((node: any) => node.f);\n\n    openHeap.push(new AStarNode(start));\n\n    while(openHeap.size() > 0) {\n\n        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n        let currentNode: AStarNode = openHeap.pop();\n\n        // End case -- result has been found, return the traced path.\n        if(currentNode.coords.row === end.coords.row && currentNode.coords.col === end.coords.col)\n            return animations.push(...getShortestPathAnimation(end))\n\n        // Normal case -- move currentNode from open to closed, process each of its neighbors.\n        currentNode.closed = true;\n\n        // Find all neighbors for the current node. Optionally find diagonal neighbors as well (false by default).\n        let neighbors = getAdjacent(currentNode, grid)\n\n        for(let i = 0; i < neighbors.length; i++) {\n            let neighbor = new AStarNode(neighbors[i]);\n\n            // Not a valid node to process, skip to next neighbor.\n            if(neighbor.closed || neighbor.isWall)\n                continue\n\n            // The g score is the shortest distance from start to current node.\n            // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n            if(!neighbor.visited || currentNode.g + neighbor.cost < neighbor.g) {\n\n                // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n                neighbor.isVisited = true;\n                neighbor.previous = currentNode;\n                neighbor.h = neighbor.h || heuristic(neighbor.pos, end.pos);\n                neighbor.g = gScore;\n                neighbor.f = neighbor.g + neighbor.h;\n\n                if (!neighbor.visited) {\n                    // Pushing to heap will put it in proper place based on the 'f' value.\n                    openHeap.push(neighbor);\n                }\n                else {\n                    // Already seen the node, but since it has been rescored we need to reorder it in the heap\n                    openHeap.rescoreElement(neighbor);\n                }\n            }\n        }\n    }\n\n    return animations.push(...noSolutionAnimations(animations));\n}\n\nfunction heuristic(pos0: number, pos1: number) {\n\n    // This is the Manhattan distance\n    let d1 = Math.abs (pos1.x - pos0.x);\n    let d2 = Math.abs (pos1.y - pos0.y);\n\n    return d1 + d2;\n}\n*/","import {NodeBackEnd} from \"../grid/NodeEngine\";\nimport {Animation, AnimationType, noSolutionAnimations} from \"../animations/AnimationsEngine\";\nimport {getShortestPathAnimation} from \"./Dijkstra\";\nimport {getAdjacent} from \"../grid/GridEngine\";\n\nexport function getBfsAnimations(grid: NodeBackEnd[][], start: NodeBackEnd, end: NodeBackEnd): Animation[] {\n\n    const animations: Animation[] = []\n    const queue: NodeBackEnd[] = []\n\n    queue.push(start)\n    start.isVisited = true\n\n    while(queue.length !== 0) {\n\n        let current: NodeBackEnd | undefined = queue.shift()\n        if(current === undefined) return []\n\n        animations.push(new Animation(AnimationType.ReachedNode, current))\n\n\n        for(const vertex of getAdjacent(current, grid)) {\n           if(!vertex.isVisited && !vertex.isWall){\n               queue.push(vertex)\n               vertex.isVisited = true\n               vertex.previous = current\n           }\n\n           if(vertex === end)\n               return animations.concat(new Animation(AnimationType.ReachedNode, vertex)).concat(...getShortestPathAnimation(end))\n        }\n\n    }\n\n    //Should reach here if it didn't found the solution\n    return animations.concat(...noSolutionAnimations(animations))\n}\n","var _g, _g2, _g3, _g4, _g5, _g6, _g7, _g8, _g9, _g10, _g11, _g12, _g13, _g14, _g15;\n\nvar _excluded = [\"title\", \"titleId\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from \"react\";\n\nfunction SvgDog(_ref, svgRef) {\n  var title = _ref.title,\n      titleId = _ref.titleId,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    id: \"Layer_1\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n    x: \"0px\",\n    y: \"0px\",\n    viewBox: \"0 0 512.001 512.001\",\n    style: {\n      enableBackground: \"new 0 0 512.001 512.001\"\n    },\n    xmlSpace: \"preserve\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#AEADB3\"\n    },\n    d: \"M62.336,204.361c-20.375-40.298-24.819-85.483-12.851-130.672 c8.979-33.905,24.07-56.018,24.708-56.943L85.748,0l79.735,92.81L62.336,204.361z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#D37B93\"\n    },\n    d: \"M141.684,113.258L90.04,53.146c-3.587,7.881-7.488,17.961-10.502,29.637 c-7.917,30.667-7.021,60.241,2.636,88.184L141.684,113.258z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#818186\"\n    },\n    d: \"M449.665,204.361c20.375-40.298,24.819-85.483,12.851-130.671 c-8.979-33.905-24.07-56.017-24.708-56.943L426.253,0l-79.735,92.81L449.665,204.361\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#9D5B6E\"\n    },\n    d: \"M370.318,113.258l51.643-60.11c3.587,7.881,7.488,17.961,10.502,29.637 c7.917,30.667,7.021,60.241-2.636,88.184L370.318,113.258\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#D8D9DD\"\n    },\n    d: \"M256.001,512c-45.417,0-80.561-14.658-107.438-44.815c-24.94-27.981-39.663-65.8-51.858-102.499 c-4.758-14.319-9.345-26.547-13.782-38.373c-13.167-35.099-23.567-62.823-23.567-107.819c0-30.689,6.978-57.096,20.741-78.489 c12.104-18.814,29.528-33.878,51.786-44.774c41.09-20.116,90.514-22.442,124.117-22.442s83.027,2.326,124.116,22.442 c22.259,10.896,39.681,25.96,51.786,44.774c13.763,21.392,20.741,47.8,20.741,78.489c0,44.996-10.4,72.719-23.567,107.819 c-4.437,11.826-9.023,24.054-13.782,38.373c-12.195,36.7-26.918,74.518-51.857,102.499C336.561,497.342,301.418,512,256.001,512\"\n  }), /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#333333\"\n    },\n    d: \"M184.887,225.811c0-11.273,9.024-20.402,20.112-20.402c11.102,0,20.124,9.13,20.124,20.402 c0,11.272-9.022,20.409-20.124,20.409C193.91,246.22,184.887,237.083,184.887,225.811z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#333333\"\n    },\n    d: \"M327.116,225.811c0-11.356-9.082-20.561-20.263-20.561c-11.195,0-20.277,9.205-20.277,20.561 c0,11.355,9.082,20.561,20.277,20.561C318.034,246.372,327.116,237.166,327.116,225.811\"\n  })), /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#444242\"\n    },\n    d: \"M240.312,511.376c5.089,0.412,10.315,0.624,15.689,0.624c5.374,0,10.599-0.212,15.689-0.624V403.575 h-31.377L240.312,511.376\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#444242\"\n    },\n    d: \"M256.001,415.799c-19.589,0-37.144-15.455-43.783-22.101c-6.662-6.669-22.157-24.326-22.157-44.22 c0-16.438,7.848-28.435,22.697-34.691c9.836-4.145,22.365-5.835,43.243-5.835s33.407,1.69,43.243,5.835 c14.849,6.257,22.697,18.253,22.697,34.691c0,19.894-15.495,37.551-22.156,44.22C293.145,400.344,275.589,415.799,256.001,415.799\"\n  })), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#BDBDBF\"\n    },\n    d: \"M452.645,218.335c0,0.052,0,0.108,0,0.16l0,0C452.645,218.442,452.645,218.388,452.645,218.335  M452.645,218.189c0,0.017,0,0.028,0,0.046C452.645,218.219,452.645,218.203,452.645,218.189 M462.949,75.35v0.001V75.35  M462.915,75.219c0.001,0.003,0.001,0.003,0.001,0.006L462.915,75.219 M462.882,75.09c0.001,0.003,0.001,0.004,0.002,0.007 C462.883,75.095,462.883,75.093,462.882,75.09 M462.847,74.957c0.001,0.005,0.002,0.009,0.004,0.016 C462.85,74.967,462.849,74.962,462.847,74.957 M462.815,74.828c0.001,0.005,0.002,0.01,0.004,0.016 C462.817,74.838,462.816,74.834,462.815,74.828 M462.779,74.693c0.002,0.008,0.004,0.017,0.006,0.025 C462.784,74.71,462.781,74.701,462.779,74.693 M462.745,74.558c0.003,0.012,0.005,0.022,0.008,0.033 C462.75,74.581,462.747,74.569,462.745,74.558 M462.711,74.429c0.003,0.012,0.005,0.022,0.008,0.032 C462.717,74.451,462.714,74.44,462.711,74.429 M462.678,74.302c0.003,0.012,0.005,0.02,0.008,0.031 C462.683,74.323,462.681,74.313,462.678,74.302 M462.642,74.167c0.003,0.012,0.007,0.027,0.01,0.038 C462.649,74.192,462.646,74.181,462.642,74.167 M462.607,74.031c0.004,0.017,0.007,0.029,0.012,0.045 C462.615,74.063,462.61,74.045,462.607,74.031 M462.568,73.885c0.005,0.019,0.011,0.044,0.017,0.064 C462.58,73.927,462.573,73.907,462.568,73.885 M256.46,72.791c0.006,0,0.006,0,0.013,0C256.467,72.791,256.465,72.791,256.46,72.791  M256.001,72.791L256.001,72.791c0.126,0,0.251,0,0.377,0C256.253,72.791,256.125,72.791,256.001,72.791 M426.253,0l-72.843,84.787 l0,0L426.253,0l11.554,16.747c0.638,0.925,15.729,23.038,24.708,56.943c0.012,0.044,0.022,0.085,0.035,0.129 c-0.011-0.043-0.023-0.087-0.035-0.129c-8.979-33.905-24.07-56.017-24.708-56.943L426.253,0\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#A0A1A5\"\n    },\n    d: \"M306.852,246.372c-11.195,0-20.277-9.205-20.277-20.561s9.082-20.561,20.277-20.561 c11.182,0,20.263,9.205,20.263,20.561C327.116,237.166,318.034,246.372,306.852,246.372 M256.001,72.791v236.162 c20.878,0,33.407,1.69,43.243,5.835c14.849,6.257,22.697,18.253,22.697,34.692c0,19.894-15.495,37.551-22.156,44.22 c-4.791,4.797-15.27,14.181-28.095,19.033v98.644c-5.05,0.409-10.232,0.621-15.561,0.624c45.357-0.027,80.458-14.687,107.311-44.815 c24.94-27.981,39.662-65.8,51.857-102.499c4.758-14.319,9.345-26.547,13.782-38.373c13.167-35.099,23.567-62.823,23.567-107.819 c0-0.052,0-0.108,0-0.16c0-0.033,0-0.067,0-0.101c0-0.017,0-0.028,0-0.046c-0.01-6.207-0.321-12.23-0.902-18.08 c0.004-0.009,0.01-0.022,0.015-0.031c-1.982-19.966-7.277-37.818-15.821-53.309c-1.273-2.307-2.616-4.56-4.033-6.762 c-11.376-17.683-27.453-32.054-47.826-42.765c-1.303-0.685-2.622-1.354-3.96-2.009c-8.61-4.215-17.587-7.65-26.707-10.444l0,0 l-0.006,0.007c-34.197-10.48-70.413-11.987-96.931-12.005c-0.006,0-0.006,0-0.013,0c-0.027,0-0.054,0-0.083,0 C256.253,72.791,256.126,72.791,256.001,72.791\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#323132\"\n    },\n    d: \"M299.243,314.787c-9.836-4.145-22.365-5.835-43.243-5.835v106.847V512c0.042,0,0.086,0,0.128,0 c5.329-0.003,10.511-0.215,15.561-0.624v-98.644c12.825-4.852,23.304-14.238,28.095-19.033c6.662-6.669,22.156-24.326,22.156-44.22 C321.94,333.04,314.093,321.045,299.243,314.787z\"\n  }), _g || (_g = /*#__PURE__*/React.createElement(\"g\", null)), _g2 || (_g2 = /*#__PURE__*/React.createElement(\"g\", null)), _g3 || (_g3 = /*#__PURE__*/React.createElement(\"g\", null)), _g4 || (_g4 = /*#__PURE__*/React.createElement(\"g\", null)), _g5 || (_g5 = /*#__PURE__*/React.createElement(\"g\", null)), _g6 || (_g6 = /*#__PURE__*/React.createElement(\"g\", null)), _g7 || (_g7 = /*#__PURE__*/React.createElement(\"g\", null)), _g8 || (_g8 = /*#__PURE__*/React.createElement(\"g\", null)), _g9 || (_g9 = /*#__PURE__*/React.createElement(\"g\", null)), _g10 || (_g10 = /*#__PURE__*/React.createElement(\"g\", null)), _g11 || (_g11 = /*#__PURE__*/React.createElement(\"g\", null)), _g12 || (_g12 = /*#__PURE__*/React.createElement(\"g\", null)), _g13 || (_g13 = /*#__PURE__*/React.createElement(\"g\", null)), _g14 || (_g14 = /*#__PURE__*/React.createElement(\"g\", null)), _g15 || (_g15 = /*#__PURE__*/React.createElement(\"g\", null)));\n}\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(SvgDog);\nexport default __webpack_public_path__ + \"static/media/dog.e2e1b757.svg\";\nexport { ForwardRef as ReactComponent };","import {\n    Accordion,\n    AccordionDetails,\n    AccordionSummary,\n    Button,\n    ButtonGroup,\n    Menu,\n    MenuItem,\n    Stack,\n    Typography\n} from \"@mui/material\";\nimport React, {useRef, useState} from \"react\";\nimport {accordionColorAlgorithms, algorithmsDropDownColor, fontColor} from \"../colors\";\nimport {Algorithm} from \"../../model/algorithms/outils/AlgorithmsEngine\";\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\n\ninterface AlgorithmMenuProps {\n    width: number\n    clicked: any\n    isBusy: boolean\n    defaultAlgorithm: Algorithm\n}\n\nexport const AlgorithmMenu = ({width, clicked, isBusy, defaultAlgorithm}: AlgorithmMenuProps) => {\n\n    const buttonSx = {backgroundColor: accordionColorAlgorithms, width: width * 0.75}\n    const [showMenu, setShowMenu] = useState(false)\n    const expandRef = useRef(null)\n\n    const toggleAndClicked = (algorithm: Algorithm) => {\n            // @ts-ignore\n            expandRef.current.click()\n            clicked(algorithm);\n    }\n\n    return (\n        <Stack direction=\"column\" width={width}>\n            <Accordion sx={{\n                backgroundColor: algorithmsDropDownColor,\n                color: fontColor,\n                marginBottom: 1\n            }} disabled={isBusy} >\n                <AccordionSummary\n                    expandIcon={<ExpandMoreIcon sx={{color: fontColor}} />}\n                    aria-controls=\"panel1a-content\"\n                    id=\"panel1a-header\"\n                    sx={{marginBottom: 0}} ref={expandRef}>\n                    <Typography fontWeight='bold' fontSize={12}>ALGORITHM: </Typography>\n                   <Typography paddingLeft={1} fontSize={12}>  {defaultAlgorithm.name}</Typography>\n                </AccordionSummary>\n                <AccordionDetails sx={{marginBottom: 1}} >\n                    <ButtonGroup\n                        orientation=\"vertical\"\n                        aria-label=\"vertical contained button group\"\n                        variant=\"contained\"\n                        sx={{marginTop: 0}}>\n                        <Button sx={buttonSx} onClick={() => toggleAndClicked(Algorithm.BidirectionalBFS)}> BFS* </Button>\n                        <Button sx={buttonSx} onClick={() => toggleAndClicked(Algorithm.Dijkstra)}> Dijkstra </Button>\n                        <Button sx={buttonSx} onClick={() => toggleAndClicked(Algorithm.Bfs)}> BFS </Button>\n                        <Button sx={buttonSx} onClick={() => toggleAndClicked(Algorithm.Dfs)}> DFS </Button>\n                    </ButtonGroup>\n                </AccordionDetails>\n            </Accordion>\n        </Stack>\n    );\n}","var _g, _g2, _g3, _g4, _g5, _g6, _g7, _g8, _g9, _g10, _g11, _g12, _g13, _g14, _g15;\n\nvar _excluded = [\"title\", \"titleId\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from \"react\";\n\nfunction SvgSteakSvgrepoCom(_ref, svgRef) {\n  var title = _ref.title,\n      titleId = _ref.titleId,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    id: \"Layer_1\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n    x: \"0px\",\n    y: \"0px\",\n    viewBox: \"0 0 330 330\",\n    style: {\n      enableBackground: \"new 0 0 330 330\"\n    },\n    xmlSpace: \"preserve\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#EDC07B\"\n    },\n    d: \"M231.666,64.444h-1.044C207.291,29.969,168.018,8.889,126.111,8.889C56.573,8.889,0,65.462,0,135v60 c0,69.538,56.573,126.111,126.111,126.111h105.555c54.222,0,98.334-44.112,98.334-98.334v-60 C330,108.557,285.888,64.444,231.666,64.444z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#FFFFFF\"\n    },\n    d: \"M126.111,90c-24.813,0-45,20.188-45,45c0,2.091,0.155,4.145,0.433,6.161 C84.558,163.068,103.389,180,126.111,180c19.837,0,36.705-12.907,42.678-30.761c1.498-4.479,2.322-9.263,2.322-14.239 C171.111,110.188,150.925,90,126.111,90z M126.111,150c-4.806,0-9.08-2.281-11.827-5.807c-1.98-2.543-3.173-5.729-3.173-9.193 c0-8.271,6.729-15,15-15s15,6.729,15,15c0,4.459-1.966,8.458-5.065,11.208C133.398,148.559,129.924,150,126.111,150z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#D7143A\"\n    },\n    d: \"M126.111,120c-8.271,0-15,6.729-15,15c0,3.465,1.192,6.65,3.173,9.193 c2.747,3.525,7.021,5.807,11.827,5.807c3.813,0,7.286-1.441,9.935-3.792c3.1-2.75,5.065-6.749,5.065-11.208 C141.111,126.729,134.383,120,126.111,120z\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#D7143A\"\n    },\n    d: \"M231.666,94.444h-9.336c-5.354,0-10.303-2.854-12.983-7.488 c-17.153-29.65-49.048-48.067-83.235-48.067C73.115,38.889,30,82.004,30,135c0,0.465,0.011,0.928,0.018,1.391 c0.747,52.357,43.563,94.721,96.094,94.721h105.555c37.68,0,68.334-30.654,68.334-68.334c0-0.467-0.026-0.928-0.035-1.393 C299.218,124.349,268.879,94.444,231.666,94.444z M126.111,180c-22.723,0-41.554-16.932-44.567-38.839 c-0.277-2.016-0.433-4.07-0.433-6.161c0-24.813,20.187-45,45-45c24.814,0,45,20.188,45,45c0,4.977-0.824,9.761-2.322,14.239 C162.816,167.093,145.948,180,126.111,180z\"\n  })), _g || (_g = /*#__PURE__*/React.createElement(\"g\", null)), _g2 || (_g2 = /*#__PURE__*/React.createElement(\"g\", null)), _g3 || (_g3 = /*#__PURE__*/React.createElement(\"g\", null)), _g4 || (_g4 = /*#__PURE__*/React.createElement(\"g\", null)), _g5 || (_g5 = /*#__PURE__*/React.createElement(\"g\", null)), _g6 || (_g6 = /*#__PURE__*/React.createElement(\"g\", null)), _g7 || (_g7 = /*#__PURE__*/React.createElement(\"g\", null)), _g8 || (_g8 = /*#__PURE__*/React.createElement(\"g\", null)), _g9 || (_g9 = /*#__PURE__*/React.createElement(\"g\", null)), _g10 || (_g10 = /*#__PURE__*/React.createElement(\"g\", null)), _g11 || (_g11 = /*#__PURE__*/React.createElement(\"g\", null)), _g12 || (_g12 = /*#__PURE__*/React.createElement(\"g\", null)), _g13 || (_g13 = /*#__PURE__*/React.createElement(\"g\", null)), _g14 || (_g14 = /*#__PURE__*/React.createElement(\"g\", null)), _g15 || (_g15 = /*#__PURE__*/React.createElement(\"g\", null)));\n}\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(SvgSteakSvgrepoCom);\nexport default __webpack_public_path__ + \"static/media/steak-svgrepo-com.267c26d5.svg\";\nexport { ForwardRef as ReactComponent };","import {ReactComponent as Dog} from \"../imgs/dog.svg\";\nimport {ReactComponent as Steak} from \"../imgs/steak-svgrepo-com.svg\";\n\nimport {NodeType} from \"../../model/grid/NodeEngine\";\n\ninterface NodeProps {\n    color: string,\n    size: number, row: number, col: number,\n    mouseDown: (row: number, col: number) => any\n    mouseEnter: (row: number, col: number) => any\n    mouseUp: (row: number, col: number) => any\n    nodeType: NodeType\n}\n\nexport const Node = ({color, size, mouseDown, mouseEnter, mouseUp, row, col, nodeType } : NodeProps) => {\n    return(\n        <div style={{\n            width: `${size}px`,\n            height: `${size}px`,\n            display: `inline-block`,\n            background: `${color}`,\n        }}  className=\"node\"\n            onMouseDown={() => mouseDown(row, col)}\n            onMouseEnter={() => mouseEnter(row, col)}\n            onMouseUp={() => mouseUp(row, col)}\n             id={`row${row}col${col}`}\n        >\n            { nodeType === NodeType.Start && <Dog width={size} height={size} /> }\n            { nodeType === NodeType.End && <Steak width={size} height={size} /> }\n        </div>\n    );\n}","import {Box} from \"@mui/material\";\nimport {NodeBackEnd} from \"../../model/grid/NodeEngine\";\nimport {Node} from \"./Node\"\n\n\ninterface CanvasProps {\n    grid: NodeBackEnd[][],\n    squareSize: number,\n    mouseDown: (row: number, col: number) => any\n    mouseEnter: (row: number, col: number) => any\n    mouseUp: (row: number, col: number) => any\n    mousePressed: () => any\n}\n\nexport const Canvas = ({grid, squareSize, mouseDown, mouseEnter, mouseUp, mousePressed}: CanvasProps) => {\n    return (\n        <Box sx={{\n            margin: 1,\n            marginLeft: 2,\n            outline: `1px solid rgba(0, 43, 162, 0.98)`,\n        }}>\n            {grid.map((row, rowIdx) => {\n                return (\n                    <div key={rowIdx} style={{fontSize: 0}}>\n                        {row.map((node, colIdx) => {\n                            const prop = {color: node.color, size: squareSize, row: node.coords.row,\n                                          col: node.coords.col, mouseIsPressed: mousePressed,\n                                          mouseEnter: mouseEnter, mouseUp: mouseUp, mouseDown: mouseDown,\n                                          key: colIdx, nodeType: node.nodeType}\n                            return (\n                                <Node {...prop}>\n                                </Node>\n                            );\n                        })}\n                    </div>\n                );\n            })}\n        </Box>\n    );\n}","import {NodeBackEnd, Point} from \"../grid/NodeEngine\";\nimport {Animation, toggleWallAnimation} from \"../animations/AnimationsEngine\";\n\n\nexport function getRecursiveDivision(grid: NodeBackEnd[][], start: Point, end: Point): Animation[] {\n    const animations: Animation[] = []\n\n    addContour(grid, animations)\n\n    recursiveDivision(true, 1, grid[0].length - 2, 1, grid.length - 2, animations, grid);\n\n    return animations\n}\n\n\nfunction recursiveDivision(h: boolean, minX: number, maxX: number, minY: number, maxY: number, animations: Animation[], grid:NodeBackEnd[][]) {\n    if (h) {\n\n        if (maxX - minX < 2) return;\n\n\n        const y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\n        addHWall(minX, maxX, y, grid, animations);\n\n        recursiveDivision(!h, minX, maxX, minY, y - 1, animations, grid);\n        recursiveDivision(!h, minX, maxX, y + 1, maxY, animations, grid);\n    } else {\n\n        if (maxY - minY < 2) return;\n\n\n        const x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\n        addVWall(minY, maxY, x, grid, animations);\n\n        recursiveDivision(!h, minX, x-1, minY, maxY, animations, grid);\n        recursiveDivision(!h, x + 1, maxX, minY, maxY, animations, grid);\n    }\n}\n\nfunction addHWall(minX: number, maxX: number, y: number, grid: NodeBackEnd[][], animations: Animation[]) {\n    const hole = Math.floor(randomNumber(minX, maxX) / 2) * 2 + 1;\n    grid[y][hole].isVisited = true\n\n    for (let i = minX; i <= maxX; i++) {\n        if (i !== hole && !grid[y][i].isVisited) {\n            grid[y][i].isWall = true\n            animations.push(...toggleWallAnimation(grid[y][i]))\n        }\n    }\n}\n\nfunction addVWall(minY: number, maxY: number, x: number, grid: NodeBackEnd[][], animations: Animation[]) {\n    const hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\n    grid[hole][x].isVisited = true\n\n    for (let i = minY; i <= maxY; i++) {\n        if (i !== hole && !grid[i][x].isVisited) {\n            grid[i][x].isWall = true\n            animations.push(...toggleWallAnimation(grid[i][x]))\n        }\n    }\n}\n\nfunction addContour(grid: NodeBackEnd[][], animations: Animation[]) {\n    for (let i = 0; i < grid.length; i++) {\n        if (i === 0 || i === (grid.length - 1)) {\n            for (let j = 0; j < grid[0].length; j++) {\n                grid[i][j].isWall = true;\n                animations.push(...toggleWallAnimation(grid[i][j]))\n            }\n        } else {\n            grid[i][0].isWall = true;\n            animations.push(...toggleWallAnimation(grid[i][0]))\n\n            grid[i][grid[0].length - 1].isWall = true;\n            animations.push(...toggleWallAnimation(grid[i][grid[0].length - 1]))\n        }\n    }\n}\nfunction randomNumber(min: number, max: number) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n","// Function puts all possible walls, and then returns the\n//walls put\nimport {NodeBackEnd} from \"../grid/NodeEngine\";\n\nexport function setPossibleWalls(grid: NodeBackEnd[][]): number[][] {\n    const nodes = []\n    // const animations = []\n\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[0].length; j++) {\n            // if( (isLimitCanvas(i, j, grid) || isInnerWall(i, j)) && !isStartEnd(i, j, grid)) {\n            //     animations.push(...toggleWallAnimation(grid[i][j]))\n            nodes.push([i, j])\n            // }\n        }\n    }\n\n    // animations.map( animation => animation.apply())\n\n    return nodes\n}\n\nexport function randomIntFromInterval(min: number, max: number) {\n    // min and max included\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport function shuffle(array: number[][]) {\n    let currentIndex = array.length,  randomIndex;\n\n    // While there remain elements to shuffle...\n    while (currentIndex !== 0) {\n\n        // Pick a remaining element...\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n\n        // And swap it with the current element.\n        [array[currentIndex], array[randomIndex]] = [\n            array[randomIndex], array[currentIndex]];\n    }\n\n    return array;\n}\n","import {MazeNodeBackEnd, NodeBackEnd, NodeType, Point} from \"../grid/NodeEngine\";\nimport {Animation, Color, toggleWallAnimation, untoggleWallAnimation} from \"../animations/AnimationsEngine\";\nimport {getAdjacent, getAllAdjacent, validCoordinate} from \"../grid/GridEngine\";\nimport {randomIntFromInterval} from \"./outils\";\nimport {Adjacent} from \"../grid/NodeEngine\";\n\n\nexport function getPrimAnimations2(grid: NodeBackEnd[][], start: Point, end: Point): Animation[] {\n\n    const animations: Animation[] = []\n    let possiblePath: MazeNodeBackEnd[] = []\n\n    //We build our graph representation (which is different when we are working\n    //with mazes than we are working with pathfinder algorithms)\n    buildGraphRepresentation(grid)\n\n    //Push the first node as an empty node and move from there\n    possiblePath.push(new MazeNodeBackEnd(grid[0][0].nodeType, 0, 0 ))\n\n    //We traverse until we have no more possible empty nodes\n    while (possiblePath.length !== 0) {\n\n        //We get the last element in the path\n        const current: MazeNodeBackEnd | undefined = possiblePath.pop()\n        if(current === undefined) return [];\n\n        //We get all adjacents vertices and their respective edjes\n        const adjacentPairs: Adjacent[] = getAdjacentMSPPairs(current, grid)\n\n        console.log(JSON.parse(JSON.stringify(current)))\n        console.log(JSON.parse(JSON.stringify(adjacentPairs)))\n\n        //We update the possible empty and add the new empty both to the grid and animations\n        //as well as pushing the other adjacent vertices to possiblePath\n        if (adjacentPairs.length > 0)\n                updatePath(possiblePath, current, adjacentPairs, animations, grid)\n\n    }\n\n    return animations\n}\n\n\n/*\nReturns an array with all the neighbours (UP, DOWN, LEFT, RIGHT) of a vertex\nwhich happen to be a new path of traversed, that is they haven't been visited\nand the edge they share with the vertex is not a wall.\n*/\nfunction getAdjacentMSPPairs(current: MazeNodeBackEnd, grid: NodeBackEnd[][]): Adjacent[] {\n    return getAdjacentPairs(current, grid).filter(adjacent => !adjacent.vertex.visitedIs())\n}\n\n/*\n* We receive the list of possible paths we can take, the current vertex,\n* a list of its adjacents and others. We select a vertex to include in our path\n* and push the others into the possiblePath\n* */\n\nfunction updatePath(possiblePath: MazeNodeBackEnd[], current: MazeNodeBackEnd, adjacent: Adjacent[],\n                    animations: Animation[], grid: NodeBackEnd[][]): void {\n\n    //We find the new empty node at random\n    const randomIdx: number = randomIntFromInterval(0, adjacent.length - 1)\n    const spanned: Adjacent = adjacent[randomIdx]\n\n    //we mark the vertex as visited\n    grid[spanned.vertex.coords.row][spanned.vertex.coords.col].visited()\n\n    spanned.vertex.visitedIs()\n\n    //We untoggle the wall as the vertex is part of the path\n    animations.push(...untoggleWallAnimation(spanned.edge))\n    spanned.edge.isWall = false\n    grid[spanned.edge.coords.row][spanned.edge.coords.col].isWall = true\n\n\n    //We now need to push all other adjacent as well as the previous\n    for(let i = 0; i < adjacent.length; i++) {\n        if(i !== randomIdx) {\n            //adjacent[i].vertex.previousAdjacent = current.previousAdjacent\n            //possiblePath.push(adjacent[i].vertex)\n        }\n    }\n\n\n    //spanned.vertex.previous = current\n    possiblePath.push(spanned.vertex)\n\n\n    //If we dont have a previous then it means we need to bind to it because\n    //the spanned vertex is a disconnected vertex, so we push a wall animation\n    //to a visited neighbor of current\n    //if(current.previousAdjacent.edge === MazeNodeBackEnd.None) {\n        //@ts-ignore\n        //animations.push(...untoggleWallAnimation(current.previousAdjacent.edge))\n        //current.previousAdjacent.vertex.visited()\n     //   console.log('disconected connected')\n    //}\n}\n\n\n/*\n* We update the grid with walls in every odd row and odd-odd pair\n* of coordenates, such that we build our desired graph representation\n* */\nfunction buildGraphRepresentation(grid: NodeBackEnd[][]) {\n    const animations = []\n\n    for (let i = 1; i < grid.length - 1; i++) {\n        for (let j = 1; j < grid[0].length - 1; j++) {\n            if(i % 2 === 1 || (j % 2 === 1 && i % 2 === 0)){\n                animations.push(...toggleWallAnimation(grid[i][j]))\n                grid[i][j].isWall = true\n            }\n            grid[i][j].unVisited()\n        }\n    }\n\n    animations.map(animation => animation.apply())\n}\n\n\n/*\n* We return list of objects of adjacent pair, the vertex adjacent and the\n* edge (or wall) that connects both\n* */\nexport function getAdjacentPairs(current: MazeNodeBackEnd, grid: NodeBackEnd[][]): Adjacent[] {\n\n    const nodes: Adjacent[] = []\n\n    //UP\n    let row = current.coords.row - 2\n    let col = current.coords.col\n    if(validCoordinate(row, col, grid))\n        nodes.push({vertex: new MazeNodeBackEnd(grid[row][col].nodeType, row, col),\n                    edge: new MazeNodeBackEnd(grid[row + 1][col].nodeType, row + 1, col)})\n\n    //LEFT\n    row = current.coords.row\n    col = current.coords.col - 2\n    if(validCoordinate(row, col, grid))\n        nodes.push({vertex: new MazeNodeBackEnd(grid[row][col].nodeType, row, col),\n            edge: new MazeNodeBackEnd(grid[row][col + 1].nodeType, row, col + 1)})\n\n\n    //DOWN\n    row = current.coords.row + 2\n    col = current.coords.col\n    if(validCoordinate(row, col, grid))\n        nodes.push({vertex: new MazeNodeBackEnd(grid[row][col].nodeType, row, col),\n            edge: new MazeNodeBackEnd(grid[row - 1][col].nodeType, row - 1, col)})\n\n\n    //RIGHT\n    row = current.coords.row\n    col = current.coords.col + 2\n    if(validCoordinate(row, col, grid))\n        nodes.push({vertex: new MazeNodeBackEnd(grid[row][col].nodeType, row, col),\n            edge: new MazeNodeBackEnd(grid[row][col - 1].nodeType, row, col -1)})\n\n\n\n    return nodes\n}\n","import {NodeBackEnd, Point} from \"../grid/NodeEngine\";\nimport {Animation, toggleWallAnimation} from \"../animations/AnimationsEngine\";\nimport {getAllAdjacent} from \"../grid/GridEngine\";\n\nexport function getRandomMazeAnimations(grid: NodeBackEnd[][], start: Point, end: Point): Animation[] {\n\n    const animations: Animation[] = []\n    const possibleWalls = setPossibleWalls(grid)\n    shuffle(possibleWalls)\n\n    while (possibleWalls.length !== 0) {\n        // @ts-ignore\n        const [row, col] = possibleWalls.pop()\n\n        if(validWall(row, col, grid)) {\n            //We push the animation that it's a wall\n            animations.push(...toggleWallAnimation(grid[row][col]))\n            //We update the grid that its a wall\n            grid[row][col].isWall = true\n            //We update neighbouring nodes in that they are visited\n\n        }\n    }\n\n    return animations\n}\n\n//We need to check that the possibleWall connects two disjoint trees,\n//that we are putting a wall in the middle of empty nodes (new tree), or\n//next to a wall that isn't touching another one (joining two trees)\nfunction validWall(row: number, col: number, grid: NodeBackEnd[][]): boolean {\n    const ans = false\n    let adjacents = 0\n\n    // @ts-ignore\n    for(const neighbor: NodeBackEnd of getAllAdjacent(grid[row][col], grid)) {\n        if(neighbor.isWall)\n            adjacents++\n    }\n\n    return adjacents < 2\n}\n\n// Function puts all possible walls, and then returns the\n//walls put\nfunction setPossibleWalls(grid: NodeBackEnd[][]): number[][] {\n    const nodes = []\n    // const animations = []\n\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[0].length; j++) {\n            // if( (isLimitCanvas(i, j, grid) || isInnerWall(i, j)) && !isStartEnd(i, j, grid)) {\n            //     animations.push(...toggleWallAnimation(grid[i][j]))\n            nodes.push([i, j])\n            // }\n        }\n    }\n\n    // animations.map( animation => animation.apply())\n\n    return nodes\n}\n\nfunction shuffle(array: number[][]) {\n    let currentIndex = array.length,  randomIndex;\n\n    // While there remain elements to shuffle...\n    while (currentIndex !== 0) {\n\n        // Pick a remaining element...\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n\n        // And swap it with the current element.\n        [array[currentIndex], array[randomIndex]] = [\n            array[randomIndex], array[currentIndex]];\n    }\n\n    return array;\n}\n","import {NodeBackEnd, Point} from \"../grid/NodeEngine\";\nimport {Animation} from \"../animations/AnimationsEngine\";\nimport {getRecursiveDivision} from \"./RecursiveDivision\";\nimport {getPrimAnimations2} from \"./Prim2\";\nimport {getRandomMazeAnimations} from \"./random\";\n\ntype getAnimationType = (grid: NodeBackEnd[][], start: Point, end: Point) => Animation[]\n\nconst primText = `\n    PRIM starts from an empty canvas. It then starts from an empty node and randomly \n    fills wall such that every empty node has a wall as a neighbour. it does so building\n    a tree at every step that is spanning (each wall adyacent to every empty node)`\n\n\nconst customMazeText =\n    `\n        The CUSTOM Maze is a blank canvas that lets you create mazes & patterns by\n        clicking on the canvas and dragging!\n    `\n\nconst recursiveDivisionText =\n    `\n        RECURSIVE Maze works by recursively dividing the canvas either horizontally or vertically,\n        by adding a wall with a hole, until it can't divide the portion of the canvas any more\n        in which point it backtracks and continues. It guarantees the existance of a solution to\n        the maze\n    `\n\nconst randomMazeText =\n    ` The RANDOM maze  works as a variation of kruskal algorithm but it doesnt\n      generate a minimum spanning tree (there doesn't exist a single connected path of empty nodes\n      that passes through all the walls) `\n\nexport class Maze {\n    static Prim = new Maze(getPrimAnimations2, \"Prim\", primText)\n    static Custom = new Maze(() => [], \"Custom\", customMazeText)\n    static Random = new Maze( getRandomMazeAnimations, \"Random\", randomMazeText)\n    static RecursiveDivison = new Maze(getRecursiveDivision, \"Recursive\", recursiveDivisionText)\n\n    public readonly animations: getAnimationType\n    public readonly name: string\n    public readonly text: string\n\n    constructor(animations: getAnimationType, name: string, text: string) {\n        this.animations = animations\n        this.name = name\n        this.text = text\n    }\n\n    create(): NodeBackEnd[][] {\n        return []\n    }\n}","import {\n    Accordion,\n    AccordionDetails,\n    AccordionSummary,\n    Button,\n    ButtonGroup,\n    Stack,\n    Typography\n} from \"@mui/material\";\nimport React, {useRef} from \"react\";\nimport {fontColor, mazesColor, mazesDropDownColor} from \"../colors\";\nimport {Maze} from \"../../model/mazes/MazesEngine\";\nimport ExpandMoreIcon from \"@mui/icons-material/ExpandMore\";\n\n\ninterface MazesProps {\n    width: number\n    clicked: any\n    isBusy: boolean\n    mazeSelected: Maze\n}\n\nexport const MazesMenu = ({width, clicked, isBusy, mazeSelected}: MazesProps) => {\n\n    const buttonSx = {backgroundColor: mazesColor, width: width * 0.75}\n    const expandRef = useRef(null)\n\n    const toggleAndClicked = (maze: Maze) => {\n        // @ts-ignore\n        expandRef.current.click()\n        clicked(maze);\n    }\n\n    return (\n        <Stack direction=\"column\" width={width} marginLeft={1}>\n            <Accordion sx={{\n                backgroundColor: mazesDropDownColor,\n                color: fontColor,\n                marginBottom: 1,\n            }} disabled={isBusy} >\n                <AccordionSummary\n                    expandIcon={<ExpandMoreIcon sx={{color: fontColor}} />}\n                    aria-controls=\"panel1a-content\"\n                    id=\"panel1a-header\"\n                    sx={{marginBottom: 0}} ref={expandRef}>\n                    <Typography fontWeight='bold' fontSize={13}>MAZE: </Typography>\n                    <Typography paddingLeft={1} fontSize={13}>  {mazeSelected.name}</Typography>\n                </AccordionSummary>\n                <AccordionDetails sx={{marginBottom: 0}} >\n                    <ButtonGroup\n                        orientation=\"vertical\"\n                        aria-label=\"vertical contained button group\"\n                        variant=\"contained\"\n                        sx={{marginTop: 0}}>\n                        <Button sx={buttonSx} onClick={() => toggleAndClicked(Maze.RecursiveDivison)}> Recursive</Button>\n                        <Button sx={buttonSx} onClick={() => toggleAndClicked(Maze.Custom)}> Custom </Button>\n                        <Button sx={buttonSx} onClick={() => toggleAndClicked(Maze.Random)}> Random </Button>\n                    </ButtonGroup>\n                </AccordionDetails>\n            </Accordion>\n        </Stack>\n    );\n}\n","import {Slider, Stack, Typography} from \"@mui/material\";\nimport SpeedRoundedIcon from \"@mui/icons-material/SpeedRounded\";\nimport React from \"react\";\nimport {speedSliderColor, speedSliderLineColor} from \"../colors\";\n\ninterface SpeedSliderProps {\n    minSpeed: number,\n    maxSpeed: number,\n    defaultSpeed: number,\n    width: number,\n    handleSpeedSlider: any,\n    isBusy: boolean\n}\n\nexport const SpeedSlider = ({minSpeed, maxSpeed, defaultSpeed, width, handleSpeedSlider, isBusy}:SpeedSliderProps) => {\n    return (\n        <Stack sx={{\n            backgroundColor: speedSliderColor,\n            marginBottom: 1,\n            color: \"white\"\n        }}>\n            <Stack>\n                <Typography id=\"animation-slider\" sx={{\n                    paddingTop: 1,\n                    paddingLeft: 2,\n                    marginRight: 2,\n                    fontWeight: 'bold',\n                    display: 'flex',\n                    alignItems: 'center',\n                    flexWrap: 'wrap',\n                    fontSize: 14\n                }}> Animation Speed\n                    <SpeedRoundedIcon sx={{paddingLeft: 1, height: 17}}/>\n                </Typography>\n            </Stack>\n            <Slider size={\"small\"} max={maxSpeed} min={minSpeed} defaultValue={defaultSpeed} key={1} sx={{\n                marginLeft: 2,\n                marginBottom: 1,\n                width: width * 0.9,\n                color: speedSliderLineColor\n            }} onChange={handleSpeedSlider} disabled={isBusy}/>\n        </Stack>\n    );\n}\n","import {NodeBackEnd, NodeType} from \"../grid/NodeEngine\";\nimport {AnimationType, Animation, Color, toggleWallAnimation} from \"./AnimationsEngine\";\n\nexport function getWallToggleAnimation(grid: NodeBackEnd[][], row: number, col: number) {\n    if(grid[row][col].nodeType === NodeType.Start || grid[row][col].nodeType === NodeType.End)\n        return []\n\n    grid[row][col].toggle()\n    return toggleWallAnimation(grid[row][col])\n}","import {Button, ButtonGroup} from \"@mui/material\";\nimport {clearButtonColor, fontColor} from \"../colors\";\n\ninterface clearButtonProps {\n    width: number,\n    clicked: () => any,\n    isBusy: boolean\n}\n\nexport const ClearButton = ({width, clicked, isBusy}: clearButtonProps) => {\n    return(\n        <ButtonGroup\n            orientation=\"vertical\"\n            aria-label=\"vertical contained button group\"\n            variant=\"contained\"\n            sx={{marginBottom: 1}}>\n\n            <Button sx={{\n                backgroundColor: clearButtonColor,\n                color: fontColor,\n                fontWeight: \"bold\",\n                width: width\n            }}\n                    onClick={clicked} disabled={isBusy}>\n               CLEAR WALLS\n            </Button>\n\n        </ButtonGroup>\n    );\n}\n","import {algorithmsDropDownColor, fontColor, informationBoxColor, mazesDropDownColor} from \"../colors\";\nimport {\n    Accordion,\n    AccordionDetails,\n    AccordionSummary,\n    Button,\n    ButtonGroup, Link,\n    Slide,\n    Stack,\n    Typography\n} from \"@mui/material\";\nimport ExpandMoreIcon from \"@mui/icons-material/ExpandMore\";\nimport {Maze} from \"../../model/mazes/MazesEngine\";\nimport React, {useEffect, useRef, useState} from \"react\";\n\nimport {Algorithm} from \"../../model/algorithms/outils/AlgorithmsEngine\";\nimport CloseIcon from \"@mui/icons-material/Close\";\n\ninterface InformationBoxProps {\n\n    algorithm: Algorithm,\n    width: number\n}\n\nexport const InformationBoxAlgorithm = ({algorithm, width}: InformationBoxProps) => {\n\n    const [show, setShow] = useState(false)\n\n    useEffect(() => {\n        setShow(true)\n    }, [algorithm])\n\n    return (\n\n        <Slide direction=\"up\" in={show} mountOnEnter unmountOnExit>\n            <Stack direction='row' sx={{backgroundColor: algorithmsDropDownColor}}>\n                <Typography sx={{color: fontColor, padding: 3, paddingRight: 0}}> {algorithm.text} </Typography>\n                <Link href=\"#\">\n                    <CloseIcon onClick={() => setShow(false)}\n                               sx={{color: fontColor, padding: 1, paddingLeft: 0}}> </CloseIcon>\n                </Link>\n            </Stack>\n        </Slide>\n\n    );\n}\n","import {Box, Grow, Link, Slide, Stack, Typography} from \"@mui/material\";\nimport {fontColor, mazesDropDownColor} from \"../colors\";\nimport CloseIcon from '@mui/icons-material/Close';\nimport {Maze} from \"../../model/mazes/MazesEngine\";\nimport React, {useEffect, useState} from \"react\";\nimport Fade from '@mui/material/Fade';\n\ninterface InformationBoxMazeProps {\n    width: number,\n    maze: Maze\n}\n\nexport const InformationBoxMaze = ({width, maze}: InformationBoxMazeProps) => {\n    const [show, setShow] = useState(false)\n\n    useEffect(() => {\n        setShow(true)\n    }, [maze])\n\n    return (\n\n        <Slide direction=\"up\" in={show} mountOnEnter unmountOnExit>\n            <Stack  direction='row' sx={{backgroundColor: mazesDropDownColor}}>\n                <Typography sx={{ color: fontColor, padding: 2.5, paddingRight: 0.5}}> {maze.text} </Typography>\n                <Link href=\"#\">\n                    <CloseIcon onClick={() => setShow(false)}\n                               sx={{color: fontColor, padding: 1, paddingLeft: 0}}> </CloseIcon>\n                </Link>\n            </Stack>\n        </Slide>\n\n    );\n}","import {Stack} from \"@mui/material\";\nimport {SolveButton} from \"./components/controllers/SolveButton\";\nimport {AlgorithmMenu} from \"./components/controllers/AlgorithmMenu\";\nimport {Canvas} from \"./components/viewer/Canvas\";\nimport {MazesMenu} from \"./components/controllers/MazesMenu\";\nimport {useEffect, useState} from \"react\";\nimport {Algorithm} from \"./model/algorithms/outils/AlgorithmsEngine\";\nimport {Animation, AnimationType} from \"./model/animations/AnimationsEngine\";\nimport {Maze} from \"./model/mazes/MazesEngine\";\nimport {clearGrid, initializeGrid, removeStartEndCoordinate, updateGrid} from \"./model/grid/GridEngine\";\nimport {NodeBackEnd, NodeType, Point} from \"./model/grid/NodeEngine\";\nimport {SpeedSlider} from \"./components/controllers/SpeedSlider\";\nimport {getWallToggleAnimation} from \"./model/animations/toggleWallAnimation\";\nimport {ClearButton} from \"./components/controllers/ClearButton\";\nimport {InformationBoxAlgorithm} from \"./components/viewer/InformationBox\";\nimport {InformationBoxMaze} from \"./components/viewer/InformationBoxMaze\";\nimport {randomIntFromInterval} from \"./model/mazes/outils\";\n\ninterface AppProps {\n    stackWidth: number,\n    columns: number\n    rows: number\n    squareSize: number\n}\n\nexport const App = ({stackWidth, columns, rows, squareSize}: AppProps) => {\n\n    //General constants for the speed of animations\n    const MAX_ANIMATION_SPEED = 100\n    const [animationSpeed, setAnimationSpeed] = useState(MAX_ANIMATION_SPEED * 0.5)\n    const defaultAnimationSpeed = MAX_ANIMATION_SPEED * 0.5\n\n    //Variables to keep track of whether an animation is running\n    //or the mouse has been pressed\n    const [mousePressed, setMousePressed] = useState(false)\n    const [isBusy, setIsBusy] = useState(false)\n\n    //We define the start and end coordinates of our dog and steak\n    //to be random and updated by these two functions\n    const [startCoordinate, setStartCoordinate] = useState(new Point(randomIntFromInterval(0, rows - 1), randomIntFromInterval(0, columns - 1)))\n    const [endCoordinate, setEndCoordinate] = useState(new Point(randomIntFromInterval(2, rows - 2), randomIntFromInterval(2, columns - 2)))\n\n    //Flags we maintain to tell whether we have selected either\n    //the start or end node to move around\n    const [startNodeSelected, setStartNodeSelected] = useState(false)\n    const [endNodeSelected, setEndNodeSelected] = useState(false)\n\n    //We keep track of our current algorithm and maze selected\n    const [algorithm, setAlgorithm] = useState(Algorithm.Bfs)\n    const [maze, setMaze] = useState(Maze.Custom)\n\n    //We keep the grid as a 2-d array of NodeBackEnd[]\n    const [grid, setGrid]: [NodeBackEnd[][], any] = useState([])\n\n    ///////////////HANDLE BUILDING THE WALLS WITH THE MOUSE/////////////////\n    const handleMouseDown = (row: number, col: number): void => {\n        if (isBusy) return\n\n        if (startNodeSelected) {\n            setStartCoordinate(new Point(row, col))\n            setStartNodeSelected(false)\n            setGrid(updateGrid(grid, columns, rows, new Point(row, col), endCoordinate)) //I NEED TO RE-INITALISE IT\n            return;\n        }\n\n        if (endNodeSelected) {\n            setEndCoordinate(new Point(row, col))\n            setEndNodeSelected(false)\n            setGrid(updateGrid(grid, columns, rows, startCoordinate, new Point(row, col))) //I NEED TO RE-INITALISE IT\n            return;\n        }\n\n        setMousePressed(true)\n\n        if (col === startCoordinate.col && row === startCoordinate.row) {\n            setStartNodeSelected(true)\n            setGrid(removeStartEndCoordinate(grid, new Point(row, col)))\n            return;\n        }\n\n        if (col === endCoordinate.col && row === endCoordinate.row) {\n            setEndNodeSelected(true)\n            setGrid(removeStartEndCoordinate(grid, new Point(row, col)))\n            return;\n\n        }\n\n        applyAnimations(getWallToggleAnimation(grid, row, col), animationSpeed)\n    }\n\n    const handleMouseEnter = (row: number, col: number): void => {\n        if (isBusy) return\n\n        if (startNodeSelected || endNodeSelected) {\n            new Animation(AnimationType.SelectedNode, grid[row][col]).apply()\n        } else if (mousePressed) {\n            applyAnimations(getWallToggleAnimation(grid, row, col), animationSpeed)\n        }\n    }\n\n    const handleMouseUp = (row: number, col: number): void => {\n        setMousePressed(false)\n    }\n\n\n    /////////////HANDLERS FOR THE CONTROLLERS//////////////////////\n\n    function handleSolveButton(): void {\n        setIsBusy(true)\n\n        const startNode = grid[startCoordinate.row][startCoordinate.col]\n        const endNode = grid[endCoordinate.row][endCoordinate.col]\n\n        applyAnimations(algorithm.getAnimations(grid, startNode, endNode), animationSpeed)\n    }\n\n    const handleAlgorithmSelected = (algorithm: Algorithm): void => {\n        setAlgorithm(algorithm)\n    }\n\n    const handleMazeSelected = (newMaze: Maze): void => {\n        if(newMaze !== Maze.Custom)\n            setIsBusy(true)\n\n        applyAnimations(newMaze.animations(grid, startCoordinate, endCoordinate), animationSpeed / 2)\n        setMaze(newMaze)\n    }\n\n    const handleAnimationSpeed = (event: any, number: number): void => {\n        setAnimationSpeed(MAX_ANIMATION_SPEED - number)\n    }\n\n    const handleCleanButton = (): void => {\n        setGrid(clearGrid(grid, columns, rows, startCoordinate, endCoordinate))\n    }\n\n    /////////////HANDLER FOR THE ANIMATIONS/////////////////////////\n    function applyAnimations(animations: Animation[], speed: number): void {\n        for (let i = 0; i < animations.length; i++) {\n            setTimeout(() => {\n                animations[i].apply()\n                if (i === animations.length - 1){\n                    setIsBusy(false)\n                    setGrid(updateGrid(grid, columns, rows, startCoordinate, endCoordinate))\n                }\n            }, speed * i)\n        }\n\n    }\n\n    useEffect(() => {\n        setGrid(initializeGrid(columns, rows, startCoordinate, endCoordinate))\n    }, [])\n\n\n    return (\n        <Stack direction=\"row\">\n            <Stack direction=\"column\" sx={{width: stackWidth, margin: 1}}>\n\n                <Stack direction={\"row\"}>\n                    <ClearButton width={stackWidth / 2} clicked={handleCleanButton.bind(this)} isBusy={isBusy}/>\n                    <SolveButton width={stackWidth / 2} clicked={handleSolveButton.bind(this)} isBusy={isBusy}/>\n                </Stack>\n\n                <SpeedSlider minSpeed={defaultAnimationSpeed / 20} maxSpeed={MAX_ANIMATION_SPEED}\n                             defaultSpeed={defaultAnimationSpeed} width={stackWidth}\n                             handleSpeedSlider={handleAnimationSpeed.bind(this)} isBusy={isBusy}/>\n\n                <Stack direction={\"row\"}>\n                    <AlgorithmMenu width={stackWidth / 2} isBusy={isBusy} defaultAlgorithm={algorithm}\n                                   clicked={handleAlgorithmSelected.bind(this)}/>\n                    <MazesMenu width={stackWidth / 2} clicked={handleMazeSelected.bind(this)} isBusy={isBusy}\n                               mazeSelected={maze}/>\n                </Stack>\n\n                <InformationBoxAlgorithm algorithm={algorithm} width={stackWidth}/>\n                <InformationBoxMaze width={stackWidth} maze={maze}/>\n\n\n            </Stack>\n\n            <Canvas grid={grid} squareSize={squareSize} mouseUp={handleMouseUp.bind(this)}\n                    mouseDown={handleMouseDown.bind(this)} mouseEnter={handleMouseEnter.bind(this)}\n                    mousePressed={() => setMousePressed(prevState => !prevState)}/>\n        </Stack>\n    );\n}\n\n\n","import {Box, Button, Modal, Stack, Typography} from \"@mui/material\";\nimport {algorithmsDropDownColor, mazesDropDownColor, welcomeText} from \"../colors\";\nimport {textStyleTutorial} from \"./tutorial/Tutorial\";\n\ninterface props {\n    display: boolean,\n    close: any,\n    width: number,\n    height: number,\n    startTutorial: any\n}\n\nconst buttonStyle = {\n    color: welcomeText,\n    '&:hover': {\n        backgroundColor: '#fff',\n        color: '#3c52b2',\n    },\n}\n\nexport const WelcomeGuide = ({display, close, width, height, startTutorial}: props) => {\n    const a = 1\n    const widthBox = width / 4\n    const heightBox = height / 4\n\n    // @ts-ignore\n    return (\n\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Box sx={{\n                backgroundColor: mazesDropDownColor,\n                width: widthBox,\n                height: heightBox,\n                marginLeft: width / 20 - widthBox / 50,\n                marginTop: height / 20 - heightBox / 50,\n                padding: 3,\n            }}>\n                <Typography sx={{\n                    fontSize: 40,\n                    color: welcomeText,\n                    fontWeight: 'bold',\n                }}>\n                    Welcome,\n                </Typography>\n                <Typography sx={{\n                    color: welcomeText,\n                    fontWeight: 'bold',\n                    paddingTop: 2\n                }}>\n                    This is a small app made in React designed to visualise different graph\n                    algorithms through maze generation and path finding\n                </Typography>\n\n                <Stack direction='row' sx={{paddingTop: 4}}>\n                    <Button onClick={close} sx={buttonStyle}> CLOSE </Button>\n                    <Button onClick={startTutorial} sx={buttonStyle} style={{marginLeft: width / 7}}> TUTORIAL</Button>\n                </Stack>\n\n            </Box>\n        </Modal>\n    );\n};\n","import {Backdrop, Box, Button, Modal, Stack, Typography} from \"@mui/material\";\nimport {buttonStyleTutorial, explanationBoxStyle, textStyleTutorial} from \"./Tutorial\";\n\ninterface functionButtonsProps {\n    display: boolean,\n    close: any,\n    marginTop: number\n}\n\nexport const FunctionButtonTutorial = ({display, close, marginTop}: functionButtonsProps) => {\n    return (\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n                <Stack direction={\"row\"} sx={{...explanationBoxStyle,  marginTop: marginTop}} >\n                <Typography sx={textStyleTutorial}>\n                    With these controllers we can clear the whole canvas, solve\n                    the maze as well as controlling the speed of the animation\n                </Typography>\n                <Button sx={buttonStyleTutorial} onClick={close}> NEXT </Button>\n                </Stack>\n        </Modal>\n    )\n}\n","import {Box, Button, Modal, Stack, Typography} from \"@mui/material\";\nimport {buttonStyleTutorial, explanationBoxStyle, textStyleTutorial} from \"./Tutorial\";\n\ninterface AlgorithmMazeTutorialProps {\n    display: boolean,\n    close: any,\n    marginTop: number\n}\n\nexport const AlgorithmMazeTutorial = ({display, close, marginTop}: AlgorithmMazeTutorialProps) => {\n    return (\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Stack direction=\"row\" style={explanationBoxStyle}\n                   sx={{marginTop: marginTop}}>\n                <Typography sx={textStyleTutorial}>\n                    The two dropdowns allows us to pick the algorithm to solve the maze and shortest path,\n                    as well as different options for generating a maze!\n                </Typography>\n                <Button sx={buttonStyleTutorial} onClick={close}> NEXT </Button>\n            </Stack>\n\n        </Modal>\n    )\n}\n","import {Button, Modal, Stack, Typography} from \"@mui/material\";\nimport {buttonStyleTutorial, explanationBoxStyle, textStyleTutorial} from \"./Tutorial\";\n\ninterface InformationBoxExplanationProps {\n    display: boolean,\n    close: any,\n    marginTop: number\n}\n\nexport const InformationBoxAlgorithm = ({display, close, marginTop}: InformationBoxExplanationProps) => {\n    return (\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Stack direction=\"row\" style={explanationBoxStyle}\n                   sx={{marginTop: marginTop}}>\n                <Typography sx={textStyleTutorial}>\n                   Here information will pop up explaining both the algorithm selected to solve the\n                   maze as well as the maze generation selected.\n                </Typography>\n                <Button sx={buttonStyleTutorial} onClick={close}> NEXT </Button>\n            </Stack>\n\n        </Modal>\n    )\n}\n","import {Button, Modal, Stack, Typography} from \"@mui/material\";\nimport {buttonStyleTutorial, explanationBoxStyle, textStyleTutorial} from \"./Tutorial\";\n\ninterface CanvasInformationProps {\n    display: boolean,\n    close: any,\n    marginTop: number\n}\n\nexport const CanvasInformation = ({display, close, marginTop}: CanvasInformationProps) => {\n    return (\n        <Modal\n            open={display}\n            onClose={close}\n            aria-labelledby=\"modal-modal-title\"\n            aria-describedby=\"modal-modal-description\">\n            <Stack direction=\"row\"\n                   sx={{...explanationBoxStyle, marginTop: marginTop}}>\n                <Typography sx={textStyleTutorial}>\n                    Finally we have the canvas, we can move the dog and the steak around by simply clicking\n                    them and them clicking where we want them. By default the maze is custom, that means if\n                    click in any empty box it becomes a wall\n                </Typography>\n                <Button sx={buttonStyleTutorial} onClick={close}> LETS PLAY!  </Button>\n            </Stack>\n\n        </Modal>\n    )\n}\n","import {useEffect, useState} from \"react\";\nimport {FunctionButtonTutorial} from \"./FunctionButtonsExplanation\";\nimport {AlgorithmMazeTutorial} from \"./AlgorithmMazeExplanation\";\nimport {InformationBoxAlgorithm} from \"./InformationBoxExplanation\";\nimport {CanvasInformation} from \"./CanvasInformation\";\n\ninterface tutorialProps {\n    start: boolean,\n    height: number\n}\n\nexport const buttonStyleTutorial = {\n    color: '#fff',\n    margin: 2,\n    '&:hover': {\n        backgroundColor: '#fff',\n        color: '#f38d8d',\n    },\n}\n\nexport const textStyleTutorial = {\n    padding: 2,\n    color: \"white\",\n    fontWeight: \"bold\"\n}\n\nexport const explanationBoxStyle = {\n    backgroundColor: \"#ff8181\",\n    width: 730,\n    \"margin-left\": 350\n}\n\n\n\nexport const Tutorial = ({start, height}: tutorialProps) => {\n\n    const [current, setCurrent] = useState(0);\n    const tutorialSteps = ['none', 'functionButtons', 'algorithmButtons', 'infoBox',  'canvas']\n\n    useEffect(() => {\n        setCurrent(start ? 1 : 0)\n    }, [start])\n\n    const next = () => {\n        setCurrent(prev => prev + 1)\n    }\n\n    return (\n        <>\n            <FunctionButtonTutorial display={tutorialSteps[current] === 'functionButtons'} close={next} marginTop={height / 500}/>\n            <AlgorithmMazeTutorial display={tutorialSteps[current] === 'algorithmButtons'} close={next} marginTop={height / 50}/>\n            <InformationBoxAlgorithm display={tutorialSteps[current] === 'infoBox'} close={next} marginTop={height / 34} />\n            <CanvasInformation display={tutorialSteps[current] === 'canvas'} close={next} marginTop={height / 11.2} />\n        </>\n);\n}\n","import {useWindowSize} from \"react-use\";\nimport {App} from \"./App\"\nimport {WelcomeGuide} from \"./components/presentation/WelcomeGuide\";\nimport {useState} from \"react\";\nimport {Tutorial} from \"./components/presentation/tutorial/Tutorial\";\n\nexport const MainApp = () => {\n\n\n    const closestOddNumber = (num: number): number => {\n        return Math.round(num) % 2 === 0 ? Math.round(num) + 1 : Math.round(num)\n    }\n\n    //Screen size and definiton\n    const {height, width} = useWindowSize();\n    const stackWidth = width * 0.22\n\n    /////Tutorial State\n    const [welcome, showWelcome] = useState(true);\n    const [startTutorial, setStartTutorial] = useState(false)\n\n\n    ///Canvas dimensions and density of boxes,\n    //for maze generation dimensions need to be odd\n    const [squareSize] = useState(24)\n    const columns = closestOddNumber(width * 0.665 / squareSize)\n    const rows = closestOddNumber(height * 0.8 / squareSize)\n\n\n    return (\n        <>\n\n            <WelcomeGuide startTutorial={() => {\n                setStartTutorial(true);\n                showWelcome(false)\n            }}\n                          close={() => showWelcome(() => false)}\n                          display={welcome} width={width} height={height}/>\n\n            <Tutorial start={startTutorial} height={height}/>\n\n            <App stackWidth={stackWidth} columns={columns} rows={rows} squareSize={squareSize}/>\n\n        </>\n    );\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {MainApp} from \"./MainApp\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <MainApp />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}